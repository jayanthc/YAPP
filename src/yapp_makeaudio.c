/**
 * @file yapp_makeaudio.c
 * Creates an audio file from filterbank or dedispersed time series data.
 *
 * @verbatim
 * Usage: yapp_makeaudio [options] <data-file>
 *     -h  --help                           Display this usage information
 *     -s  --skip <time>                    The length of data in seconds, to be
 *                                          skipped
 *                                          (default is 0 s)
 *     -p  --proc <time>                    The length of data in seconds, to be
 *                                          processed
 *                                          (default is all)
 *     -a  --ampfactor <amp-scale-factor>   Amplitude scale factor
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @author Desh
 * @date 2007.*.*
*/

#include "yapp.h"
#include <sndfile.h>

#define CHANNEL_COUNT       1
#define FILE_EXT            ".wav"

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* data file */
extern FILE *g_pFData;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
float *g_pfBuf = NULL;
int main(int argc, char *argv[])
{
    char *pcFileData = NULL;
    int iFormat = DEF_FORMAT;
    double dDataSkipTime = 0.0;
    double dDataProcTime = 0.0;
    SF_INFO stSFInfo = {0};
    SNDFILE *pFSndFile = NULL;
    char acFileSnd[LEN_GENSTRING] = {0};
    YUM_t stYUM = {{0}};
    float fMean = 0.0;
    float fRMS = 0.0;
    int iFileSize = 0;
    int iTimeSamps = 0;
    int iSampRate = 0;
    long lBytesToSkip = 0;
    long lBytesToProc = 0;
    int iTimeSampsToSkip = 0;
    int iTimeSampsToProc = 0;
    float fAmpFactor = 0.0;
    struct stat stFileStats;
    int iRet = YAPP_RET_SUCCESS;
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    int i = 0;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hs:p:a:v";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "skip",                   1, NULL, 's' },
        { "proc",                   1, NULL, 'p' },
        { "ampfactor",              1, NULL, 'a' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 's':   /* -s or --skip */
                /* set option */
                dDataSkipTime = atof(optarg);
                break;

            case 'p':   /* -p or --proc */
                /* set option */
                dDataProcTime = atof(optarg);
                break;

            case 'a':   /* -a or --ampfactor */
                /* set option */
                fAmpFactor = atof(optarg);
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileData = argv[optind];

    /* determine the file type */
    iFormat = YAPP_GetFileType(pcFileData);
    if (YAPP_RET_ERROR == iFormat)
    {
        (void) fprintf(stderr,
                       "ERROR: File type determination failed!\n");
        return YAPP_RET_ERROR;
    }
    if (!((YAPP_FORMAT_FIL == iFormat)
          || (YAPP_FORMAT_SPEC == iFormat)
          || (YAPP_FORMAT_DTS_TIM == iFormat)
          || (YAPP_FORMAT_DTS_DAT == iFormat)))
    {
        (void) fprintf(stderr,
                       "ERROR: Invalid file type!\n");
        return YAPP_RET_ERROR;
    }

    /* read metadata */
    iRet = YAPP_ReadMetadata(pcFileData, iFormat, &stYUM);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Reading metadata failed for file %s!\n",
                       pcFileData);
        return YAPP_RET_ERROR;
    }

    /* convert sampling interval to seconds */
    dTSampInSec = stYUM.dTSamp / 1e3;

    /* copy next beam-flip time */
    dTNextBF = stYUM.dTNextBF;

    /* validate number of bands */
    if ((YAPP_TRUE == stYUM.iFlagSplicedData) && (iNumBands <= 1))
    {
        (void) fprintf(stderr,
                       "ERROR: Number of bands must be > 1 for spliced "
                       "data!\n");
        return YAPP_RET_ERROR;
    }

    /* calculate bytes to skip and read */
    if (0.0 == dDataProcTime)
    {
        dDataProcTime = (stYUM.iTimeSamps * dTSampInSec) - dDataSkipTime;
    }
    /* check if the input time duration is less than the length of the
       data */
    else if (dDataProcTime > (stYUM.iTimeSamps * dTSampInSec))
    {
        (void) fprintf(stderr,
                       "WARNING: Input time is longer than length of "
                       "data!\n");
    }

    lBytesToSkip = (long) floor((dDataSkipTime / dTSampInSec)
                                                    /* number of samples */
                           * stYUM.iNumChans
                           * stYUM.fSampSize);
    lBytesToProc = (long) floor((dDataProcTime / dTSampInSec)
                                                    /* number of samples */
                           * stYUM.iNumChans
                           * stYUM.fSampSize);

    if (lBytesToSkip >= stYUM.lDataSizeTotal)
    {
        (void) fprintf(stderr,
                       "ERROR: Data to be skipped is greater than or equal to "
                       "the size of the file!\n");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if ((lBytesToSkip + lBytesToProc) > stYUM.lDataSizeTotal)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        lBytesToProc = stYUM.lDataSizeTotal - lBytesToSkip;
        dDataProcTime = ((double) lBytesToProc * dTSampInSec)
                        / (stYUM.iNumChans * stYUM.fSampSize);
        (void) printf("Newly calculated size of data to be processed: %ld "
                      "bytes\n",
                      lBytesToProc);
    }

    iTimeSampsToSkip = (int) (lBytesToSkip
                              / (stYUM.iNumChans * stYUM.fSampSize));
    (void) printf("Skipping\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n",
                  lBytesToSkip,
                  stYUM.lDataSizeTotal,
                  iTimeSampsToSkip,
                  stYUM.iTimeSamps,
                  (iTimeSampsToSkip * dTSampInSec),
                  (stYUM.iTimeSamps * dTSampInSec));

    iTimeSampsToProc = (int) (lBytesToProc
                              / (stYUM.iNumChans * stYUM.fSampSize));
    iNumReads = (int) ceilf((float) iTimeSampsToProc / iBlockSize);
    iTotNumReads = iNumReads;

    /* change block size according to the number of samples to be processed */
    if (iTimeSampsToProc < iBlockSize)
    {
        iBlockSize = (int) ceil(dDataProcTime / dTSampInSec);
    }

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = stYUM.iNumChans * iBlockSize;

    (void) printf("Processing\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n"
                  "in %d reads with block size %d time samples...\n",
                  lBytesToProc,
                  stYUM.lDataSizeTotal,
                  iTimeSampsToProc,
                  stYUM.iTimeSamps,
                  (iTimeSampsToProc * dTSampInSec),
                  (stYUM.iTimeSamps * dTSampInSec),
                  iNumReads,
                  iBlockSize);

    /* generate the output file name */
    (void) strncat(acFileSnd, pcFileData, LEN_GENSTRING);
    (void) strncat(acFileSnd, FILE_EXT, LEN_GENSTRING);

    iTimeSamps = stYUM.iTimeSamps;
    (void) printf("Number of time samples            : %d\n", iTimeSamps);

    /* open the data file for reading */
    g_pFData = fopen(pcFileData, "r");
    if (NULL == g_pFData)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileData,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* get the size of the file */
    iRet = stat(pcFileData, &stFileStats);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to stat %s: %s!\n",
                       pcFileData,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    iFileSize = stFileStats.st_size;
    (void) printf("Dedispersed data file size        : %d\n", iFileSize);

    g_pfBuf = (float *) YAPP_Malloc(iTimeSamps,
	                                sizeof(float),
									YAPP_FALSE);
    if (NULL == g_pfBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for data failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if ((YAPP_FORMAT_FIL == iFormat) || (YAPP_FORMAT_DTS_TIM == iFormat))
    {
        /* skip the header */
        (void) fseek(g_pFData, (long) stYUM.iHeaderLen, SEEK_SET);
    }

    iSampRate = (int) roundf((float) 1e3 / stYUM.dTSamp);
    printf("Sampling rate = %d\n", iSampRate);

    /* read the dedispersed data */
    iRet = fread(g_pfBuf, sizeof(float), iTimeSamps, g_pFData);
    if (ferror(g_pFData))
    {
        (void) fprintf(stderr, "ERROR: Reading data failed!\n");
        return YAPP_RET_ERROR;
    }

#if 0
    ss = (char *)&g_pfBuf[1];
                printf(" ss1,2,3,4 %d %d %d %d\n",ss[0],ss[1],ss[2],ss[3]);
        printf("%f\n", g_pfBuf[1]);
    if (cFlagSwap)
    {       // s = (char *)g_pfBuf;
        //s_temp = (char *)f_temp;
        for (i = 0; i < iTimeSamps; ++i)
        {
    //  printf("%f    ", g_pfBuf[i]);
            f_temp = g_pfBuf[i];
            s_temp = (char *) &f_temp;
            x_char = s_temp[0];
            s_temp[0] = s_temp[3];
            s_temp[3] = x_char;
            x_char = s_temp[1];
            s_temp[1] = s_temp[2];
            s_temp[2] = x_char;
            g_pfBuf[i] = f_temp;
    //  printf("    %f\n", g_pfBuf[i]);
        }
        printf(" ss1,2,3,4 %d %d %d %d\n",ss[0],ss[1],ss[2],ss[3]);
        printf("%x\n", (int) &g_pfBuf[1]);
    }
#endif

    /* calculate the mean of the data, subtract the mean from the
       samples, and multiply the signal by fAmpFactor */
    fMax = g_pfBuf[0];
    fMin = g_pfBuf[0];
    fMean = 0.0;
    for (i = 1; i < iTimeSamps; ++i)
    {
        if (g_pfBuf[i] > fMax)
        {
            fMax = g_pfBuf[i];
        }
        if (g_pfBuf[i] < fMin)
        {
            fMin = g_pfBuf[i];
        }
        fMean += g_pfBuf[i];
        fRMS += (g_pfBuf[i] * g_pfBuf[i]);
    }
    fMean = fMean / iTimeSamps;
    fRMS = sqrtf(fRMS / iTimeSamps);
    printf("min,max: %f %f; Mean %f, RMS %g\n",fMin,fMax,fMean, fRMS);

    for (i = 0; i < iTimeSamps; ++i)
    {
        g_pfBuf[i] -= fMean;
        g_pfBuf[i] = powf(10, g_pfBuf[i]);
        //g_pfBuf[i] *= fAmpFactor;
    }

    /* set the parameters for the WAVE file */
    stSFInfo.samplerate = iSampRate;
    stSFInfo.channels = CHANNEL_COUNT;
    stSFInfo.format = (SF_FORMAT_WAV | SF_FORMAT_FLOAT);

    /* open the WAVE file and write the processed data */
    pFSndFile = sf_open(acFileSnd, SFM_WRITE, &stSFInfo);
    if (NULL == pFSndFile)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to open WAVE file: %s!\n",
                       sf_strerror(pFSndFile));
        free(g_pfBuf);
        return YAPP_RET_ERROR;
    }
//  if (sf_write_int(pFSndFile, g_pfBuf, iFileSize) != iFileSize)
    if (sf_write_float(pFSndFile, g_pfBuf, iTimeSamps) != iTimeSamps)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to write to WAVE file: %s!\n",
                       sf_strerror(pFSndFile));
        free(g_pfBuf);
        sf_close(pFSndFile);
        return YAPP_RET_ERROR;
    }

    /* clean up */
    sf_close(pFSndFile);
    free(g_pfBuf);
    fclose(g_pFData);

    return YAPP_RET_SUCCESS;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <data-file>\n",
                  pcProgName);
    (void) printf("    -h  --help                          ");
    (void) printf("Display this usage information\n");
    (void) printf("    -s  --skip <time>                   ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                        ");
    (void) printf("skipped\n");
    (void) printf("    -p  --proc <time>                   ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                        ");
    (void) printf("processed\n");
    (void) printf("                                        ");
    (void) printf("(default is all)\n");
    (void) printf("    -a  --ampfactor <amp-scale-factor>  ");
    (void) printf("Amplitude scale factor\n");
    (void) printf("    -v  --version                       ");
    (void) printf("Display the version\n");

    return;
}

