/**
 * @file yapp_dedisp.c
 * Program to dedisperse the input signal for the given value of DM.
 *
 * @verbatim
 * Usage: yapp_dedisp [options] <dynamic-spectrum-data-file>
 *     -h  --help                           Display this usage information
 *     -d  --dm <dm>                        The DM at which to de-disperse
 *                                          (default is 10.0)
 *     -s  --skip-percent <percentage>      The percentage of data to be skipped
 *     -S  --skip-time <time>               The length of data in seconds, to be
 *                                          skipped
 *     -p  --proc-percent <percentage>      The percentage of data to be
 *                                          processed
 *                                          (default is 100)
 *     -P  --proc-time <time>               The length of data in seconds, to be
 *                                          processed
 *                                          (default is all)
 *     -b  --block-size <samples>           Number of samples read in one block
 *                                          (default is 4096 samples)
 *     -c  --clip-level <level>             Number of sigmas above threshold;
 *                                          will clip anything above this level
 *     -t  --out-format                     Output format - 'ddd' or 'tim'
 *                                          (default is 'tim')
 *     -o  --no-plots                       Run without displaying plots
 *     -f  --plot-to-file                   Plot to a PostScript file, instead
 *                                          of the screen
 *     -i  --invert                         Invert the background and foreground
 *                                          colours in plots
 *     -n  --interactive                    Run in interactive mode
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2008.11.14
 */

/* TODO: 1. ORT & MST radar data reads nan or inf for the last few samples of
            data
         2. No need for DEF_PROC_TIME */

#include "yapp.h"
#include "yapp_sigproc.h"   /* for SIGPROC filterbank file format support */
#include "colourmap.h"

/* TODO: Handle the headerless/header-separated filterbank format file */

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

int g_iDispPlots = YAPP_TRUE;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
double *g_pdDelayTab = NULL;
char *g_pcIsChanGood = NULL;
char *g_pcIsTimeGood = NULL;
float *g_pfBFTimeSectMean = NULL;
float *g_pfBFGain = NULL;
double (*g_padBadTimes)[][NUM_BAD_BOUNDS] = NULL;
float *g_pfBuf0 = NULL;
float *g_pfBuf1 = NULL;
float *g_pfPlotBuf = NULL;
float *g_pfDedispData = NULL;
float *g_pfXAxis = NULL;
float *g_pfYAxis = NULL;

int main(int argc, char *argv[])
{
    FILE *pFSpec = NULL;
    FILE *pFCfg = NULL;
    FILE *pFDedispData = NULL;
    char *pcFileSpec = NULL;
    char acFileCfg[LEN_GENSTRING] = {0};
    char acFileDedisp[LEN_GENSTRING] = {0};
    int iFormat = DEF_FORMAT;
    int iOutputFormat = DEF_OUT_FORMAT;
    char cIsPlotToFile = YAPP_FALSE;
    int iDataSkipPercent = DEF_SKIP_PERCENT;
    int iDataSkipTime = DEF_SKIP_TIME;
    int iDataProcPercent = DEF_PROC_PERCENT;
    int iDataProcTime = DEF_PROC_TIME;
    int iProcSpec = PROC_SPEC_NOTSEL;   /* by default, the processing
                                           specification is not selected */
    char cIsDMGiven = YAPP_FALSE;
    int iChanGoodness = (int) YAPP_TRUE;
    double dDelay = 0.0;
    double dDM = 0.0;
    float fFMin = 0.0;
    float fFMax = 0.0;
    float fChanBW = 0.0;
    int iMaxOffset = 0;
    int iNumChans = 0;
    float fSampSize = 0.0;      /* number of bits that make a sample */
    int iTotSampsPerBlock = 0;  /* iNumChans * iBlockSize */
    int iDataSizePerBlock = 0;  /* fSampSize * iNumChans * iBlockSize */
    int iNumGoodChans = 0;
    int iEffcNumGoodChans = 0;
    char cIsBandFlipped = YAPP_FALSE;
    float fStatBW = 0.0;
    float fNoiseRMS = 0.0;
    float fThreshold = 0.0;
    float fSNRMin = 0.0;
    float fClipLevel = 0.0;
    double dNumSigmas = 0.0;
    float fF1 = 0.0;
    float fF2 = 0.0;
    double dTSamp = 0.0;        /* holds sampling time in ms */
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    YAPP_SIGPROC_HEADER stHeader = {{0}};
    char acLabel[LEN_GENSTRING] = {0};
    int iHeaderLen = 0;
    int iLen = 0;
    float fFCh1 = 0.0;          /* frequency of the first channel */
    double dMaxDelay = 0.0;
    int iBytesPerFrame = 0;
    float fFCentre = 0.0;
    float fBW = 0.0;
    int iChanBeg = 0;
    int iChanEnd = 0;
    char acPulsar[LEN_GENSTRING] = {0};
    int iDay = 0;
    int iMonth = 0;
    int iYear = 0;
    int iHour = 0;
    int iMin = 0;
    float fSec = 0.0;
    char acSite[LEN_GENSTRING] = {0};
    double dTNextBF = 0.0;
    double dTBFInt = 0.0;
    int iBFTimeSects = 0;
    float *pfTimeSectGain = NULL;
    int iNumBadTimes = 0;
    double dTNow = 0.0;
    int iTimeSect = 0;
    int iBadTimeSect = 0;
    char cIsInBadTimeRange = YAPP_FALSE;
    float *pfPriBuf = NULL;
    float *pfSecBuf = NULL;
    float *pfSpectrum = NULL;
    float *pfOffsetSpec = NULL;
    int iPrimaryBuf = BUF_0;
    int iOffset = 0;
    int iBytesToSkip = 0;
    int iBytesToProc = 0;
    int iTimeSamps = 0;
    int iTimeSampsSkip = 0;
    int iTimeSampsToProc = 0;
    int iBlockSize = DEF_SIZE_BLOCK;
    int iNumReads = 0;
    int iTotNumReads = 0;
    int iReadBlockCount = 0;
    int iReadSmpCount = 0;         /* (iReadBlockCount - 1) * iBlockSize */
    int iSecBufReadSampCount = 0;   /* iReadBlockCount * iBlockSize */
    char cIsLastBlock = YAPP_FALSE;
    struct stat stFileStats = {0};
    int iDataSizeTotal = 0;
    int iRet = YAPP_RET_SUCCESS;
    float afTM[6] = {0.0};
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    int iReadItems = 0;
    char acDev[LEN_GENSTRING] = {0};
    char *pcFilename = NULL;
    float fColMin = 0.0;
    float fColMax = 0.0;
    float fXStep = 0.0;
    float fYStep = 0.0;
    int iNumSamps = 0;
    int iDiff = 0;
    int i = 0;
    int j = 0;
    int k = 0;
    int l = 0;
    int m = 0;
    int iInvCols = YAPP_FALSE;
    char cIsInteractive = YAPP_FALSE;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hf:d:s:S:p:P:b:c:t:oignv";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "format",                 1, NULL, 'f' },
        { "dm",                     1, NULL, 'd' },
        { "skip-percent",           1, NULL, 's' },
        { "skip-time",              1, NULL, 'S' },
        { "proc-percent",           1, NULL, 'p' },
        { "proc-time",              1, NULL, 'P' },
        { "block-size",             1, NULL, 'b' },
        { "clip-level",             1, NULL, 'c' },
        { "out-format",             1, NULL, 't' },
        { "invert",                 0, NULL, 'i' },
        { "no-plots",               0, NULL, 'o' },
        { "plot-to-file",           0, NULL, 'g' },
        { "interactive",            0, NULL, 'n' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 'f':   /* -f or --format */
                /* set option */
                if (0 == strcmp(optarg, YAPP_FORMATSTR_SPEC))
                {
                    iFormat = YAPP_FORMAT_SPEC;
                }
                else if (0 == strcmp(optarg, YAPP_FORMATSTR_FIL))
                {
                    iFormat = YAPP_FORMAT_FIL;
                }
                else
                {
                    (void) fprintf(stderr,
                                   "ERROR: Format should be either 'spec' or "
                                   "'fil'!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'd':   /* -d or --dm-limit */
                /* set option */
                dDM = atof(optarg);
                cIsDMGiven = YAPP_TRUE;
                break;

            case 's':   /* -s or --skip-percent */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_PERCENT == iProcSpec))
                {
                    iDataSkipPercent = atoi(optarg);
                    if (iDataSkipPercent > 100)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Data skip percentage should be "
                                       "less than 100!\n");
                        PrintUsage(pcProgName);
                        return YAPP_RET_ERROR;
                    }

                    iProcSpec = PROC_SPEC_PERCENT;
                }
                else    /* if the specification mode is time, not percentage */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'S':   /* -S or --skip-time */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_TIME == iProcSpec))
                {
                    iDataSkipTime = atoi(optarg);
                    iProcSpec = PROC_SPEC_TIME;
                }
                else    /* if the specification mode is percentage, not time */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'p':   /* -p or --proc-percent */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_PERCENT == iProcSpec))
                {
                    iDataProcPercent = atoi(optarg);
                    if (iDataProcPercent > 100)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Data processing percentage "
                                       "should be less than 100!\n");
                        PrintUsage(pcProgName);
                        return YAPP_RET_ERROR;
                    }

                    iProcSpec = PROC_SPEC_PERCENT;
                }
                else    /* if the specification mode is time, not percentage */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'P':   /* -P or --proc-time */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_TIME == iProcSpec))
                {
                    iDataProcTime = atoi(optarg);
                    iProcSpec = PROC_SPEC_TIME;
                }
                else    /* if the specification mode is percentage, not time */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'b':   /* -b or --block-size */
                /* set option */
                iBlockSize = atoi(optarg);
                break;

            case 'c':   /* -c or --clip-level */
                /* set option */
                fClipLevel = (float) atof(optarg);
                break;

            case 't':   /* -t or --out-format */
                /* set option */
                if (0 == strcmp(optarg, YAPP_FORMATSTR_DTS_DDD))
                {
                    iOutputFormat = YAPP_FORMAT_DTS_DDD;
                }
                else if (0 == strcmp(optarg, YAPP_FORMATSTR_DTS_TIM))
                {
                    iOutputFormat = YAPP_FORMAT_DTS_TIM;
                }
                else
                {
                    (void) fprintf(stderr,
                                   "ERROR: Format should be either 'ddd' or "
                                   "'tim'!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'i':  /* -i or --invert */
                /* set option */
                iInvCols = YAPP_TRUE;
                break;

            case 'o':   /* -o or --no-plots */
                /* set option */
                g_iDispPlots = YAPP_FALSE;
                break;

            case 'g':   /* -g or --plot-to-file */
                /* set option */
                cIsPlotToFile = YAPP_TRUE;
                break;

            case 'n':  /* -n or --interactive */
                /* set option */
                cIsInteractive = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    if (!(cIsDMGiven))
    {
        (void) fprintf(stderr,
                       "ERROR: Required option not given! DM is required.\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileSpec = argv[optind];

    /* determine the file type */
    iFormat = YAPP_GetFileType(pcFileSpec);
    if (YAPP_RET_ERROR == iFormat)
    {
        (void) fprintf(stderr,
                       "ERROR: File type determination failed!\n");
        return YAPP_RET_ERROR;
    }

    /* read metadata */
    iRet = YAPP_ReadMetadata(pcFileSpec, iFormat, &stYUM);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Reading metadata failed for file %s!\n",
                       pcFileSpec);
        return YAPP_RET_ERROR;
    }
    pfTimeSectGain = stYUM.pfBFGain;//if DAS
    //for SIGPROC -->
    iNumChans = stYUM.iNumChans;//for SIGPROC
        /* flag all channels as good */
        g_pcIsChanGood = (char *) malloc(sizeof(char) * iNumChans);
        if (NULL == g_pcIsChanGood)
        {
            perror("malloc - g_pcIsChanGood");
            (void) fclose(pFCfg);
            return YAPP_RET_ERROR;
        }
        /* set all elements to 'YAPP_TRUE' */
        (void) memset(g_pcIsChanGood, YAPP_TRUE, iNumChans);
    //<--for SIGPROC

    g_pdDelayTab = (double *) malloc(sizeof(double) * iNumChans);
    if (NULL == g_pdDelayTab)
    {
        perror("malloc - g_pdDelayTab");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* calculate quadratic delays */
    /* NOTE: g_pdDelayTab[k] may not be 0 for the highest frequency channel,
       but the offset samples may be (depending on the sampling rate) */
#ifdef DEBUG
    {
        FILE *pFFileDelaysQuad = NULL;

        pFFileDelaysQuad = fopen(YAPP_FILE_DELAYS_QUAD, "w");
        if (NULL == pFFileDelaysQuad)
        {
            fprintf(stderr,
                    "ERROR: Opening file %s failed! %s.\n",
                    YAPP_FILE_DELAYS_QUAD,
                    strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
#endif
    if (dDM < 0)
    {
        if (cIsBandFlipped)
        {
            fF1 = fFMax;
            fF2 = fFMin;
            for (k = 0; k < iNumChans; ++k)
            {
                g_pdDelayTab[k] = -4.148808e6
                                  * ((1.0 / powf(fF1, 2))
                                     - (1.0 / powf(fF2, 2)))
                                  * dDM;    /* in ms */
#ifdef DEBUG
                (void) fprintf(pFFileDelaysQuad,
                               "%d %g %d\n",
                               k,
                               g_pdDelayTab[k],
                               (int) -(g_pdDelayTab[k]/dTSamp));
#endif
                fF2 += fChanBW;
            }
            dMaxDelay = g_pdDelayTab[0];
        }
        else
        {
            fF1 = fFMin;
            fF2 = fFMax;
            for (k = iNumChans - 1; k >= 0; --k)
            {
                g_pdDelayTab[k] = 4.148808e6
                                  * ((1.0 / powf(fF1, 2))
                                     - (1.0 / powf(fF2, 2)))
                                  * dDM;     /* in ms */
#ifdef DEBUG
                (void) fprintf(pFFileDelaysQuad,
                               "%d %g %d\n",
                               k,
                               g_pdDelayTab[k],
                               (int) -(g_pdDelayTab[k]/dTSamp));
#endif
                fF2 -= fChanBW;
            }
            dMaxDelay = g_pdDelayTab[iNumChans-1];
        }
    }
    else
    {
        if (cIsBandFlipped)
        {
            fF1 = fFMin;
            fF2 = fFMax;
            for (k = iNumChans - 1; k >= 0; --k)
            {
                g_pdDelayTab[k] = -4.148808e6
                                  * ((1.0 / powf(fF1, 2))
                                     - (1.0 / powf(fF2, 2)))
                                  * dDM;     /* in ms */
#ifdef DEBUG
                (void) fprintf(pFFileDelaysQuad,
                               "%d %g %d\n",
                               k,
                               g_pdDelayTab[k],
                               (int) -(g_pdDelayTab[k]/dTSamp));
#endif
                fF2 -= fChanBW;
            }
            dMaxDelay = g_pdDelayTab[iNumChans-1];
        }
        else
        {
            fF1 = fFMax;
            fF2 = fFMin;
            for (k = 0; k < iNumChans; ++k)
            {
                g_pdDelayTab[k] = 4.148808e6
                                  * ((1.0 / powf(fF1, 2))
                                     - (1.0 / powf(fF2, 2)))
                                  * dDM;    /* in ms */
#ifdef DEBUG
                (void) fprintf(pFFileDelaysQuad,
                               "%d %g %d\n",
                               k,
                               g_pdDelayTab[k],
                               (int) -(g_pdDelayTab[k]/dTSamp));
#endif
                fF2 += fChanBW;
            }
            dMaxDelay = g_pdDelayTab[0];
        }
    }
#ifdef DEBUG
        (void) fclose(pFFileDelaysQuad);
    }
#endif

    /* calculate the maximum sample offset from the maximum delay */
    iMaxOffset = (int) -(dMaxDelay / dTSamp);

    /* ensure that the block size is at least equivalent to the maximum offset,
       because we don't read beyond the second buffer */
    if (iBlockSize < iMaxOffset)
    {
        (void) printf("WARNING: Block size is less than the calculated maximum "
                      "offset! Changing block size to %d.\n",
                      iMaxOffset);
        iBlockSize = iMaxOffset;
    }

    /* check which of the data processing specification modes - percentage or
       time - has been selected by the user, and calculate bytes to skip and
       read */
    if (PROC_SPEC_TIME == iProcSpec)
    {
        /* ensure that the input time duration is less than the length of the
           data */
        if (((double) iDataProcTime) > (iTimeSamps * dTSampInSec))
        {
            (void) fprintf(stderr,
                           "ERROR: Input time is longer than length of "
                           "data!\n");
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        iBytesToSkip = (int) ((iDataSkipTime * 1000.0 / dTSamp)
                                                        /* number of samples */
                              * iNumChans
                              * fSampSize);
        iBytesToProc = (int) ((iDataProcTime * 1000.0 / dTSamp)
                                                        /* number of samples */
                              * iNumChans
                              * fSampSize);
    }
    else    /* if it is not selected, or percentage is selected, use percentage
               mode */
    {
        iBytesToSkip = (int) (floorf(iTimeSamps
                                     * (((float) iDataSkipPercent) / 100))
                                                        /* number of samples */
                              * iNumChans
                              * fSampSize);
        iBytesToProc = (int) (ceilf(iTimeSamps
                                    * (((float) iDataProcPercent) / 100))
                                                        /* number of samples */
                              * iNumChans
                              * fSampSize);
    }

    if (iBytesToSkip >= iDataSizeTotal)
    {
        (void) printf("WARNING: Data to be skipped is greater than or equal to "
                      "the size of the file! Terminating.\n");
        YAPP_CleanUp();
        return YAPP_RET_SUCCESS;
    }

    if ((iBytesToSkip + iBytesToProc) > iDataSizeTotal)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        iBytesToProc = iDataSizeTotal - iBytesToSkip;
        (void) printf("Newly calculated size of data to be processed: %d "
                      "bytes\n",
                      iBytesToProc);
    }

    if (iBlockSize == iMaxOffset)
    {
        if (iBytesToProc < (iBlockSize * iNumChans * sizeof(float)))
        {
            /* if the block size is equivalent to the maximum delay that is to
               be applied, and if the number of bytes to be processed is less
               than the block size, de-dispersion will be affected, as we don't
               have more than two block buffers. if both conditions are true,
               force the number of bytes to be processed to be equivalent to the
               block size/maximum offset */
            (void) printf("WARNING: Amount of data to be processed is less "
                          "than the calculated maximum offset! Will process "
                          "more data than what was requested.\n");
            iBytesToProc = iBlockSize * iNumChans * sizeof(float);
        }
    }
    else
    {
        /* here, iBlockSize > iMaxOffset */
        assert(iBlockSize > iMaxOffset);

        if (iBytesToProc < (iMaxOffset * iNumChans * sizeof(float)))
        {
            /* if the number of bytes to be processed is less than the maximum
               offset, de-dispersion will be affected, as we don't have more
               than two block buffers. in this situation, force the number of
               bytes to be processed to be equivalent to the maximum offset */
            (void) printf("WARNING: Amount of data to be processed is less "
                          "than the calculated maximum offset! Will process "
                          "more data than what was requested.\n");
            iBytesToProc = iMaxOffset * iNumChans *sizeof(float);
            (void) printf("WARNING: Amount of data to be processed is less "
                          "than the block size! Adjusting block size "
                          "accordingly.\n");
            iBlockSize = iBytesToProc / (iNumChans * sizeof(float));
        }
        else
        {
            if (iBytesToProc < (iBlockSize * iNumChans * sizeof(float)))
            {
                /* here, iMaxOffset <=(eqv) iBytesToProc <(eqv) iBlockSize */
                (void) printf("WARNING: Amount of data to be processed is less "
                              "than the block size! Adjusting block size "
                              "accordingly.\n");
                iBlockSize = iBytesToProc / (iNumChans * sizeof(float));
            }
        }
    }

    /* since we may have adjusted the number of bytes to be processed, correct
       the number of bytes to be skipped, too */
    if ((iBytesToSkip + iBytesToProc) > iDataSizeTotal)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        iBytesToSkip = iDataSizeTotal - iBytesToProc;
        (void) printf("Newly calculated size of data to be skipped: %d bytes\n",
                      iBytesToSkip);
    }

    iTimeSampsSkip = (int) (iBytesToSkip / (iNumChans * fSampSize));
    (void) printf("Skipping %d of %d bytes (%d time samples)...\n",
                  iBytesToSkip,
                  iDataSizeTotal,
                  iTimeSampsSkip);

    iTimeSampsToProc = (int) (iBytesToProc / (iNumChans * fSampSize));
    iNumReads = (int) ceilf(((float) iTimeSampsToProc) / iBlockSize);
    iTotNumReads = iNumReads;

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = iNumChans * iBlockSize;
    iDataSizePerBlock = (int) (fSampSize * iTotSampsPerBlock);

    (void) printf("Processing\n"
                  "    %d of %d bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n"
                  "in %d reads with block size %d time samples...\n",
                  iBytesToProc,
                  iDataSizeTotal,
                  iTimeSampsToProc,
                  iTimeSamps,
                  (iTimeSampsToProc * dTSampInSec),
                  (iTimeSamps * dTSampInSec),
                  iNumReads,
                  iBlockSize);

    /* calculate the threshold */
    dNumSigmas = YAPP_CalcThresholdInSigmas(iTimeSampsToProc);
    if ((double) YAPP_RET_ERROR == dNumSigmas)
    {
        (void) fprintf(stderr, "ERROR: Threshold calculation failed!\n");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    fStatBW = iNumGoodChans * fChanBW;  /* in MHz */
    (void) printf("Usable bandwidth                  : %g MHz\n", fStatBW);
    fNoiseRMS = 1.0 / sqrt(fStatBW * dTSamp * 1e3);
    (void) printf("Expected noise RMS                : %g\n", fNoiseRMS);
    fThreshold = (float) (dNumSigmas * fNoiseRMS);
    (void) printf("Threshold                         : %g\n", fThreshold);
    /* calculate the minimum SNR */
    fSNRMin = fThreshold / fNoiseRMS;

    /* allocate memory for the time sample goodness flag array */
    g_pcIsTimeGood = (char *) malloc(sizeof(char) * iTimeSampsToProc);
    if (NULL == g_pcIsTimeGood)
    {
        perror("malloc - g_pcIsTimeGood");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    /* set all elements to 'YAPP_TRUE' */
    (void) memset(g_pcIsTimeGood, YAPP_TRUE, iTimeSampsToProc);

    /* open the dynamic spectrum data file for reading */
    pFSpec = fopen(pcFileSpec, "r");
    if (NULL == pFSpec)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileSpec,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* allocate memory for the primary and secondary buffers, based on the
       number of channels and time samples */
    g_pfBuf0 = (float *) malloc(sizeof(float) * iNumChans * iBlockSize);
    if (NULL == g_pfBuf0)
    {
        perror("malloc - g_pfBuf0");
        (void) fclose(pFSpec);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    g_pfBuf1 = (float *) malloc(sizeof(float) * iNumChans * iBlockSize);
    if (NULL == g_pfBuf1)
    {
        perror("malloc - g_pfBuf1");
        (void) fclose(pFSpec);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if (1 == iNumReads)
    {
        cIsLastBlock = YAPP_TRUE;
    }

    /* allocate memory for storing the dedispersed data */
    g_pfDedispData = (float *) malloc(sizeof(float) * iBlockSize);
    if (NULL == g_pfDedispData)
    {
        perror("malloc - g_pfDedispData");
        (void) fclose(pFSpec);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if (YAPP_FORMAT_FIL == iFormat)
    {
        /* skip the header */
        (void) fseek(pFSpec, (long) iHeaderLen, SEEK_SET);
        /* skip data, if any are to be skipped */
        (void) fseek(pFSpec, (long) iBytesToSkip, SEEK_CUR);
    }
    else
    {
        /* skip data, if any are to be skipped */
        (void) fseek(pFSpec, (long) iBytesToSkip, SEEK_SET);
    }

    /* read the first block of data */
    (void) printf("Reading data block %d.\n", iReadBlockCount);
    (void) YAPP_ReadData(pFSpec, g_pfBuf0, fSampSize, iTotSampsPerBlock);
    pfPriBuf = g_pfBuf0;
    pfSpectrum = g_pfBuf0;
    iPrimaryBuf = BUF_0;
    --iNumReads;
    ++iReadBlockCount;

    if (YAPP_FORMAT_SPEC == iFormat)
    {
        /* flag bad time sections, and if required, normalise within the beam
           flip time section and perform gain correction */
        for (i = 0; i < iBlockSize; ++i)
        {
            dTNow += dTSampInSec;   /* in s */

            if ((dTNow >= (*g_padBadTimes)[iBadTimeSect][BADTIME_BEG])
                && (dTNow <= (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
            {
                cIsInBadTimeRange = YAPP_TRUE;
                g_pcIsTimeGood[i] = YAPP_FALSE;
            }

            if ((YAPP_TRUE == cIsInBadTimeRange)
                && (dTNow > (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
            {
                cIsInBadTimeRange = YAPP_FALSE;
                ++iBadTimeSect;
            }

            /* get the beam flip time section corresponding to this
               sample */
            if (dTNow > dTNextBF)
            {
                dTNextBF += dTBFInt;
                if (iTimeSect >= iBFTimeSects)
                {
                    (void) fprintf(stderr,
                                   "ERROR: Beam flip time section anomaly "
                                   "detected!\n");
                    (void) fclose(pFSpec);
                    YAPP_CleanUp();
                    return YAPP_RET_ERROR;
                }
                ++iTimeSect;
            }

            pfTimeSectGain = g_pfBFGain + iTimeSect * iNumChans;
            pfSpectrum = pfPriBuf + i * iNumChans;
            for (j = 0; j < iNumChans; ++j)
            {
                if (g_pcIsChanGood[j])
                {
                    /* clip points, if they cross the user-specified maximum
                       sigmas */
                    if (fClipLevel != 0.0)
                    {
                        if (pfSpectrum[j] > ((dNumSigmas + fClipLevel)
                                             * fNoiseRMS))
                        {
                            pfSpectrum[j] = (dNumSigmas + fClipLevel)
                                            * fNoiseRMS;
                        }
                        else if (pfSpectrum[j] < -((dNumSigmas + fClipLevel)
                                                   * fNoiseRMS))
                        {
                            pfSpectrum[j] = -((dNumSigmas + fClipLevel)
                                                  * fNoiseRMS);
                        }
                    }

                    pfSpectrum[j] = (pfSpectrum[j]
                                     / g_pfBFTimeSectMean[iTimeSect])
                                    - pfTimeSectGain[j];
                }
            }
        }
    }

    if (g_iDispPlots)
    {
        /* open the PGPLOT graphics device */
        if (cIsPlotToFile)
        {
            /* build the name of the PGPLOT device */
            pcFilename = YAPP_GetFilenameFromPath(pcFileSpec, EXT_DYNSPEC);
            (void) strcpy(acDev, pcFilename);
            free(pcFilename);
            (void) strcat(acDev, PLOT_DDS_SUFFIX);
            (void) strcat(acDev, EXT_PS);
            (void) strcat(acDev, PG_DEV_PS);

            iRet = cpgopen(acDev);
            if (iRet <= 0)
            {
                (void) fprintf(stderr,
                               "ERROR: Opening graphics device %s failed!\n",
                               acDev);
                (void) fclose(pFSpec);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            cpgask(YAPP_FALSE);
        }
        else
        {
            iRet = cpgopen(PG_DEV);
            if (iRet <= 0)
            {
                (void) fprintf(stderr,
                               "ERROR: Opening graphics device %s failed!\n",
                               PG_DEV);
                (void) fclose(pFSpec);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            cpgask(YAPP_TRUE);
        }

       /* set the background colour to white and the foreground colour to
          black, if user requires so */
       if (YAPP_TRUE == iInvCols)
       {
           cpgscr(0, 1.0, 1.0, 1.0);
           cpgscr(1, 0.0, 0.0, 0.0);
       }

        /* set up the plot's X-axis */
        g_pfXAxis = (float *) malloc(sizeof(float) * iBlockSize);
        if (NULL == g_pfXAxis)
        {
            perror("malloc - g_pfXAxis");
            cpgclos();
            (void) fclose(pFSpec);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        /* set up the image plot's Y-axis (frequency) */
        g_pfYAxis = (float *) malloc(sizeof(float) * iNumChans);
        if (NULL == g_pfYAxis)
        {
            perror("malloc - g_pfYAxis");
            cpgclos();
            (void) fclose(pFSpec);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        for (i = 0; i < iNumChans; ++i)
        {
            g_pfYAxis[i] = fFMin + i * fChanBW;
        }

        /* calculate the tick step sizes */
        fXStep = (int) ((((iBlockSize - 1) * dTSampInSec) - 0)
                        / PG_TICK_STEPS_X);
        fYStep = (int) ((fFMax - fFMin) / PG_TICK_STEPS_Y);

        /* allocate memory for the cpgimag() plotting buffer */
        g_pfPlotBuf = (float *) malloc(sizeof(float) * iNumChans * iBlockSize);
        if (NULL == g_pfPlotBuf)
        {
            perror("malloc - g_pfPlotBuf");
            cpgclos();
            (void) fclose(pFSpec);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
    }

    /* generate dedispersed data file name and config file name from the input
       file name */
    pcFilename = YAPP_GetFilenameFromPath(pcFileSpec, EXT_DYNSPEC);

    (void) strcpy(acFileDedisp, pcFilename);
    (void) strcat(acFileDedisp, EXT_DEDISPSPEC);

    free(pcFilename);

    pFDedispData = fopen(acFileDedisp, "w");
    if (NULL == pFDedispData)
    {
        fprintf(stderr,
                "ERROR: Opening file %s failed! %s.\n",
                acFileDedisp,
                strerror(errno));
        (void) fclose(pFSpec);
        return YAPP_RET_ERROR;
    }

    /* add header for .tim file format */
    if (YAPP_FORMAT_DTS_TIM == iOutputFormat)
    {
        /* write the parameters to the header section of the file */
        /* start with the 'HEADER_START' label */
        iLen = strlen("HEADER_START");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "HEADER_START");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);

        /* write the rest of the header */
        /* write source name */
        /* write field label length */
        iLen = strlen("source_name");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        /* write field label */
        (void) strcpy(acLabel, "source_name");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        iLen = strlen(stHeader.acPulsar);
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) fwrite(stHeader.acPulsar, sizeof(char), iLen, pFDedispData);

        /* write data type */
        iLen = strlen("data_type");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "data_type");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        /* set the data type to 'time series (topocentric)' */
        stHeader.iDataTypeID = 2;
        (void) fwrite(&stHeader.iDataTypeID,
                      sizeof(stHeader.iDataTypeID),
                      1,
                      pFDedispData);

        /* write number of channels */
        iLen = strlen("nchans");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "nchans");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        /* set the number of channels to 1 */
        stHeader.iNumChans = 1;
        (void) fwrite(&stHeader.iNumChans,
                      sizeof(stHeader.iNumChans),
                      1,
                      pFDedispData);

        /* write frequency of first channel */
        iLen = strlen("fch1");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "fch1");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dFChan1,
                      sizeof(stHeader.dFChan1),
                      1,
                      pFDedispData);

        /* write number of bits per sample */
        iLen = strlen("nbits");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "nbits");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        /* set the number of bits per sample to 32 */
        stHeader.iNumBits = YAPP_SAMPSIZE_32;
        (void) fwrite(&stHeader.iNumBits,
                      sizeof(stHeader.iNumBits),
                      1,
                      pFDedispData);

        /* write number of IFs */
        iLen = strlen("nifs");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "nifs");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.iNumIFs,
                      sizeof(stHeader.iNumIFs),
                      1,
                      pFDedispData);

        /* write sampling time in seconds */
        iLen = strlen("tsamp");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "tsamp");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dTSamp,
                      sizeof(stHeader.dTSamp),
                      1,
                      pFDedispData);

        /* write timestamp of first sample (MJD) */
        iLen = strlen("tstart");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "tstart");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dTStart,
                      sizeof(stHeader.dTStart),
                      1,
                      pFDedispData);

        /* write telescope ID */
        iLen = strlen("telescope_id");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "telescope_id");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.iObsID,
                      sizeof(stHeader.iObsID),
                      1,
                      pFDedispData);

        /* write backend ID */
        iLen = strlen("machine_id");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "machine_id");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.iBackendID,
                      sizeof(stHeader.iBackendID),
                      1,
                      pFDedispData);

        /* write source RA (J2000) */
        iLen = strlen("src_raj");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "src_raj");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dSourceRA,
                      sizeof(stHeader.dSourceRA),
                      1,
                      pFDedispData);

        /* write source declination (J2000) */
        iLen = strlen("src_dej");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "src_dej");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dSourceDec,
                      sizeof(stHeader.dSourceDec), 1, pFDedispData);

        /* write azimuth start */
        iLen = strlen("az_start");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "az_start");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dAzStart,
                      sizeof(stHeader.dAzStart),
                      1,
                      pFDedispData);

        /* write ZA start */
        iLen = strlen("za_start");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "za_start");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.dZAStart,
                      sizeof(stHeader.dZAStart),
                      1,
                      pFDedispData);

        /* write reference DM */
        iLen = strlen("refdm");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "refdm");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        /* set the DM */
        stHeader.dDM = dDM;
        (void) fwrite(&stHeader.dDM, sizeof(stHeader.dDM), 1, pFDedispData);

        /* write barycentric flag */
        iLen = strlen("barycentric");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "barycentric");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
        (void) fwrite(&stHeader.iFlagBary,
                      sizeof(stHeader.iFlagBary),
                      1,
                      pFDedispData);

        /* write header end tag */
        iLen = strlen("HEADER_END");
        (void) fwrite(&iLen, sizeof(iLen), 1, pFDedispData);
        (void) strcpy(acLabel, "HEADER_END");
        (void) fwrite(acLabel, sizeof(char), iLen, pFDedispData);
    }

    /* set up the plots */
    if (g_iDispPlots)
    {
        cpgsubp(1, 3);

        afTM[0] = 1;
        afTM[1] = 1;
        afTM[3] = 1;
        afTM[5] = 1;
    }

    /* dedisperse the data */
    while (iNumReads >= 0)
    {
        /* for optimisation - calculate ((iReadBlockCount - 1) * iBlockSize) */
        iReadSmpCount = (iReadBlockCount - 1) * iBlockSize;

        if (g_iDispPlots)
        {
            /* common for all panels */
            for (i = 0; i < iBlockSize; ++i)
            {
                g_pfXAxis[i] = (iReadSmpCount * dTSampInSec)
                               + (i * dTSampInSec);
            }

            cpgpanl(1, 1);

            pfSpectrum = pfPriBuf;
            fDataMin = pfSpectrum[0];
            fDataMax = pfSpectrum[0];
            for (j = 0; j < iBlockSize; ++j)
            {
                pfSpectrum = pfPriBuf + j * iNumChans;
                for (k = 0; k < iNumChans; ++k)
                {
                    if (pfSpectrum[k] < fDataMin)
                    {
                        fDataMin = pfSpectrum[k];
                    }
                    if (pfSpectrum[k] > fDataMax)
                    {
                        fDataMax = pfSpectrum[k];
                    }
                }
            }

            (void) printf("Minimum value of data             : %g\n", fDataMin);
            (void) printf("Maximum value of data             : %g\n", fDataMax);

            if (-fThreshold > fDataMin)
            {
                fColMin = -fThreshold;
            }
            else
            {
                fColMin = fDataMin;
            }
            if (fThreshold < fDataMax)
            {
                fColMax = fThreshold;
            }
            else
            {
                fColMax = fDataMax;
            }

            /* set the colour map */
            //SetColourMap(iColourMap, 0, fColMin, fColMax);

            /* get the transpose of the two-dimensional array */
            k = 0;
            l = 0;
            m = 0;
            for (i = 0; i < iBlockSize; ++i)
            {
                pfSpectrum = pfPriBuf + i * iNumChans;
                for (j = 0; j < iNumChans; ++j)
                {
                    g_pfPlotBuf[l] = pfSpectrum[j];
                    l = m + k * iBlockSize;
                    ++k;
                }
                k = 0;
                l = ++m;
            }

            cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
            cpgswin(1, (iBlockSize - 2), 1, (iNumChans - 2));
            cpgbox("C", 0.0, 0, "C", 0.0, 0);
            cpgaxis("N",
                    1, 1,
                    (iBlockSize - 2), 1,
                    g_pfXAxis[1], g_pfXAxis[iBlockSize-2],
                    fXStep,
                    0,
                    0.0,
                    0.4,
                    1.0,
                    0.8,
                    0);
            cpgaxis("N",
                    1, 1,
                    1, (iNumChans - 2),
                    g_pfYAxis[1], g_pfYAxis[iNumChans-2],
                    fYStep,
                    0,
                    0.4,
                    0.0,
                    1.0,
                    -0.8,
                    0);
            cpglab("Time (s)", "Frequency (MHz)", "Before De-Dispersion");
            cpgimag(g_pfPlotBuf,
                    iBlockSize,
                    iNumChans,
                    1,
                    (iBlockSize - 2),
                    1,
                    (iNumChans - 2),
                    fDataMin,
                    fDataMax,
                    afTM);
            cpgwedg("RI", 1.0, 5.0, fDataMin, fDataMax, "");
        }

        /* read the next data block, for reading samples that would be
           shifted in */
        if (!(cIsLastBlock))
        {
            (void) printf("Reading data block %d.\n", iReadBlockCount);
            if (BUF_0 == iPrimaryBuf)
            {
                iReadItems = YAPP_ReadData(pFSpec,
                                           g_pfBuf1,
                                           fSampSize,
                                           iTotSampsPerBlock);
                pfSecBuf = g_pfBuf1;
            }
            else
            {
                iReadItems = YAPP_ReadData(pFSpec,
                                           g_pfBuf0,
                                           fSampSize,
                                           iTotSampsPerBlock);
                pfSecBuf = g_pfBuf0;
            }
            if (ferror(pFSpec))
            {
                (void) fprintf(stderr, "ERROR: File read failed!\n");
                if (g_iDispPlots)
                {
                    cpgclos();
                }
                (void) fclose(pFDedispData);
                (void) fclose(pFSpec);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            if (iReadItems < iTotSampsPerBlock)
            {
                iDiff = iTotSampsPerBlock - iReadItems;

                /* reset remaining elements to '\0' */
                if (BUF_0 == iPrimaryBuf)
                {
                    (void) memset((g_pfBuf1 + iReadItems),
                                  '\0',
                                  (sizeof(float) * iDiff));
                }
                else
                {
                    (void) memset((g_pfBuf0 + iReadItems),
                                  '\0',
                                  (sizeof(float) * iDiff));
                }
            }

            /* calculate the number of time samples in the block - this may not
               be iBlockSize for the last block, and should be iBlockSize for
               all other blocks */
            iNumSamps = iReadItems / iNumChans;

            /* get the actual count of read samples, inclusive of those in the
               first buffer */
            iSecBufReadSampCount = iReadBlockCount * iBlockSize;

            if (YAPP_FORMAT_SPEC == iFormat)
            {
                /* flag bad time sections, and if required, normalise within
                   the beam flip time section and perform gain correction */
                for (i = 0; i < iNumSamps; ++i)
                {
                    dTNow += dTSampInSec;   /* in s */

                    if ((dTNow >= (*g_padBadTimes)[iBadTimeSect][BADTIME_BEG])
                        && (dTNow
                            <= (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
                    {
                        cIsInBadTimeRange = YAPP_TRUE;
                        g_pcIsTimeGood[iSecBufReadSampCount+i] = YAPP_FALSE;
                    }

                    if ((YAPP_TRUE == cIsInBadTimeRange)
                        && (dTNow
                            > (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
                    {
                        cIsInBadTimeRange = YAPP_FALSE;
                        ++iBadTimeSect;
                    }

                    /* get the beam flip time section corresponding to this
                       sample */
                    if (dTNow > dTNextBF)
                    {
                        dTNextBF += dTBFInt;
                        if (iTimeSect >= iBFTimeSects)
                        {
                            (void) fprintf(stderr,
                                           "ERROR: Beam flip time section "
                                           "anomaly detected!\n");
                            if (g_iDispPlots)
                            {
                                cpgclos();
                            }
                            (void) fclose(pFDedispData);
                            (void) fclose(pFSpec);
                            YAPP_CleanUp();
                            return YAPP_RET_ERROR;
                        }
                        ++iTimeSect;
                    }

                    pfTimeSectGain = g_pfBFGain + iTimeSect * iNumChans;
                    pfSpectrum = pfSecBuf + i * iNumChans;
                    for (j = 0; j < iNumChans; ++j)
                    {
                        if (g_pcIsChanGood[j])
                        {
                            /* clip points, if they cross the user-specified
                               maximum sigmas */
                            if (fClipLevel != 0.0)
                            {
                                if (pfSpectrum[j] > ((dNumSigmas + fClipLevel)
                                                     * fNoiseRMS))
                                {
                                    pfSpectrum[j] = (dNumSigmas + fClipLevel)
                                                    * fNoiseRMS;
                                }
                                else if (pfSpectrum[j] < -((dNumSigmas
                                                            + fClipLevel)
                                                           * fNoiseRMS))
                                {
                                    pfSpectrum[j] = -((dNumSigmas + fClipLevel)
                                                      * fNoiseRMS);
                                }
                            }

                            pfSpectrum[j] = (pfSpectrum[j]
                                             / g_pfBFTimeSectMean[iTimeSect])
                                            - pfTimeSectGain[j];
                        }
                    }
                }
            }
        }

        (void) printf("Processing data block %d.\n", (iReadBlockCount - 1));

        /* clear the g_pfDedispData array */
        (void) memset(g_pfDedispData,
                      '\0',
                      (sizeof(float) * iBlockSize));

        for (k = 0; k < iBlockSize; ++k)
        {
            pfSpectrum = pfPriBuf + k * iNumChans;
            for (l = 0; l < iNumChans; ++l)
            {
                if (g_pcIsChanGood[l])
                {
                    /* get the delay for the corresponding DM and frequency
                       channel from the delay table */
                    dDelay = g_pdDelayTab[l];
                    /* calculate the sample number offset from the delay */
                    iOffset = (int) -(dDelay / dTSamp);
                    /* apply the delay - shift all time samples up */
                    if ((k + iOffset) >= iBlockSize)
                    {
                        if (!(cIsLastBlock))
                        {
                            m = k + iOffset - iBlockSize;
                            pfOffsetSpec = pfSecBuf + m * iNumChans;
                            pfSpectrum[l] = pfOffsetSpec[l];
                            if (g_pcIsTimeGood[iReadSmpCount+k+iOffset])
                            {
                                g_pfDedispData[k] += pfSpectrum[l];
                                ++iEffcNumGoodChans;
                            }
                        }
                    }
                    else
                    {
                        pfOffsetSpec = pfPriBuf
                                       + (k + iOffset) * iNumChans;
                        pfSpectrum[l] = pfOffsetSpec[l];
                        if (g_pcIsTimeGood[iReadSmpCount+k+iOffset])
                        {
                            g_pfDedispData[k] += pfSpectrum[l];
                            ++iEffcNumGoodChans;
                        }
                    }
                }
            }

            /* get the average over all the good channels */
            if (iEffcNumGoodChans != 0)
            {
                g_pfDedispData[k] /= iEffcNumGoodChans;
            }
            else
            {
                g_pfDedispData[k] = 0.0;
            }

             g_pfDedispData[k] /= fNoiseRMS;

            /* reset the effective number of good channels */
            iEffcNumGoodChans = 0;
        }

        if (g_iDispPlots)
        {
            cpgpanl(1, 2);

            pfSpectrum = pfPriBuf;
            fDataMin = pfSpectrum[0];
            fDataMax = pfSpectrum[0];
            for (j = 0; j < iBlockSize; ++j)
            {
                pfSpectrum = pfPriBuf + j * iNumChans;
                for (k = 0; k < iNumChans; ++k)
                {
                    if (pfSpectrum[k] < fDataMin)
                    {
                        fDataMin = pfSpectrum[k];
                    }
                    if (pfSpectrum[k] > fDataMax)
                    {
                        fDataMax = pfSpectrum[k];
                    }
                }
            }

            (void) printf("Minimum value of data             : %g\n", fDataMin);
            (void) printf("Maximum value of data             : %g\n", fDataMax);

            if (-fThreshold > fDataMin)
            {
                fColMin = -fThreshold;
            }
            else
            {
                fColMin = fDataMin;
            }
            if (fThreshold < fDataMax)
            {
                fColMax = fThreshold;
            }
            else
            {
                fColMax = fDataMax;
            }

#if 0
            iFlagBW = YAPP_FALSE;

            /* for nitro
            set_colours__(&iFlagBW, &fColMin, &fColMax);
            */
#endif
            SetColourMap(CMAP_JET, 0, fColMin, fColMax);

            /* get the transpose of the two-dimensional array */
            k = 0;
            l = 0;
            m = 0;
            for (i = 0; i < iBlockSize; ++i)
            {
                pfSpectrum = pfPriBuf + i * iNumChans;
                for (j = 0; j < iNumChans; ++j)
                {
                    g_pfPlotBuf[l] = pfSpectrum[j];
                    l = m + k * iBlockSize;
                    ++k;
                }
                k = 0;
                l = ++m;
            }

            cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
            cpgswin(1, (iBlockSize - 2), 1, (iNumChans - 2));
            cpgbox("C", 0.0, 0, "C", 0.0, 0);
            cpgaxis("N",
                    1, 1,
                    (iBlockSize - 2), 1,
                    g_pfXAxis[1], g_pfXAxis[iBlockSize-2],
                    fXStep,
                    0,
                    0.0,
                    0.4,
                    1.0,
                    0.8,
                    0);
            cpgaxis("N",
                    1, 1,
                    1, (iNumChans - 2),
                    g_pfYAxis[1], g_pfYAxis[iNumChans-2],
                    fYStep,
                    0,
                    0.4,
                    0.0,
                    1.0,
                    -0.8,
                    0);
            cpglab("Time (s)", "Frequency (MHz)", "After De-Dispersion");
            cpgimag(g_pfPlotBuf,
                    iBlockSize,
                    iNumChans,
                    1,
                    (iBlockSize - 2),
                    1,
                    (iNumChans - 2),
                    fDataMin,
                    fDataMax,
                    afTM);
            cpgwedg("RI", 1.0, 5.0, fDataMin, fDataMax, "");
        }

        (void) fwrite(g_pfDedispData,
                      sizeof(float),
                      iBlockSize,
                      pFDedispData);

        if (g_iDispPlots)
        {
            cpgpanl(1, 3);

            fDataMin = g_pfDedispData[0];
            fDataMax = g_pfDedispData[0];
            for (l = 0; l < iBlockSize; ++l)
            {
                if (g_pfDedispData[l] < fDataMin)
                {
                    fDataMin = g_pfDedispData[l];
                }
                if (g_pfDedispData[l] > fDataMax)
                {
                    fDataMax = g_pfDedispData[l];
                }
            }

            (void) printf("Minimum value of data             : %g\n", fDataMin);
            (void) printf("Maximum value of data             : %g\n", fDataMax);

            cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);

            cpgswin(g_pfXAxis[0], g_pfXAxis[iBlockSize-1], fDataMin, fDataMax);
            cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
            cpglab("Time (s)", "", "");
            cpgline(iBlockSize, g_pfXAxis, g_pfDedispData);

            if (!(cIsLastBlock))
            {
                cpgpage();
            }
        }

        if (BUF_0 == iPrimaryBuf)
        {
            iPrimaryBuf = BUF_1;
            pfPriBuf = g_pfBuf1;
        }
        else
        {
            iPrimaryBuf = BUF_0;
            pfPriBuf = g_pfBuf0;
        }

        --iNumReads;
        ++iReadBlockCount;
        if (0 == iNumReads)
        {
            cIsLastBlock = YAPP_TRUE;
        }
    }

    (void) printf("DONE!\n");

    if (g_iDispPlots)
    {
        cpgclos();
    }

    (void) fclose(pFDedispData);
    (void) fclose(pFSpec);
    YAPP_CleanUp();

    return YAPP_RET_SUCCESS;
}

/*
 * Cleans up all allocated memory
 */
void YAPP_CleanUp()
{
    if (g_pfDedispData != NULL)
    {
        free(g_pfDedispData);
        g_pfDedispData = NULL;
    }
    if (g_pfBuf0 != NULL)
    {
        free(g_pfBuf0);
        g_pfBuf0 = NULL;
    }
    if (g_pfBuf1 != NULL)
    {
        free(g_pfBuf1);
        g_pfBuf1 = NULL;
    }
    if (g_pdDelayTab != NULL)
    {
        free(g_pdDelayTab);
        g_pdDelayTab = NULL;
    }
    if (g_padBadTimes != NULL)
    {
        free(g_padBadTimes);
        g_padBadTimes = NULL;
    }
    if (g_pfBFGain != NULL)
    {
        free(g_pfBFGain);
        g_pfBFGain = NULL;
    }
    if (g_pfBFTimeSectMean != NULL)
    {
        free(g_pfBFTimeSectMean);
        g_pfBFTimeSectMean = NULL;
    }
    if (g_pcIsChanGood != NULL)
    {
        free(g_pcIsChanGood);
        g_pcIsChanGood = NULL;
    }
    if (g_pcIsTimeGood != NULL)
    {
        free(g_pcIsTimeGood);
        g_pcIsTimeGood = NULL;
    }
    if (g_iDispPlots)
    {
        if (g_pfPlotBuf != NULL)
        {
            free(g_pfPlotBuf);
            g_pfPlotBuf = NULL;
        }
        if (g_pfXAxis != NULL)
        {
            free(g_pfXAxis);
            g_pfXAxis = NULL;
        }
        if (g_pfYAxis != NULL)
        {
            free(g_pfYAxis);
            g_pfYAxis = NULL;
        }
    }

    return;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <dynamic-spectrum-data-file>\n",
                  pcProgName);
    (void) printf("    -h  --help                           ");
    (void) printf("Display this usage information\n");
    (void) printf("    -f  --format <format>                ");
    (void) printf("Select the format - 'spec' or 'fil'\n");
    (void) printf("                                         ");
    (void) printf("(default is 'spec')\n");
    (void) printf("    -d  --dm <dm>                        ");
    (void) printf("The DM at which to de-disperse\n");
    (void) printf("                                         ");
    (void) printf("(default is 10.0)\n");
    (void) printf("    -s  --skip-percent <percentage>      ");
    (void) printf("The percentage of data to be skipped\n");
    (void) printf("    -S  --skip-time <time>               ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                         ");
    (void) printf("skipped\n");
    (void) printf("    -p  --proc-percent <percentage>      ");
    (void) printf("The percentage of data to be processed\n");
    (void) printf("                                         ");
    (void) printf("(default is 100)\n");
    (void) printf("    -P  --proc-time <time>               ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                         ");
    (void) printf("processed\n");
    (void) printf("                                         ");
    (void) printf("(default is all)\n");
    (void) printf("    -b  --block-size <samples>           ");
    (void) printf("Number of samples read in one block\n");
    (void) printf("                                         ");
    (void) printf("(default is 4096 samples)\n");
    (void) printf("    -c  --clip-level <level>             ");
    (void) printf("Number of sigmas above threshold; will\n");
    (void) printf("                                         ");
    (void) printf("clip anything above this level\n");
    (void) printf("    -t  --out-format                     ");
    (void) printf("Output format - 'ddd' or 'tim'\n");
    (void) printf("                                         ");
    (void) printf("(default is 'tim')\n");
    (void) printf("    -o  --no-plots                       ");
    (void) printf("Run without displaying plots\n");
    (void) printf("    -f  --plot-to-file                   ");
    (void) printf("Plot to a PostScript file, instead of\n");
    (void) printf("                                         ");
    (void) printf("the screen\n");
    (void) printf("    -i  --invert                         ");
    (void) printf("Invert the background and foreground\n");
    (void) printf("                                         ");
    (void) printf("colours in plots\n");
    (void) printf("    -n  --interactive                    ");
    (void) printf("Run in interactive mode\n");
    (void) printf("    -v  --version                        ");
    (void) printf("Display the version\n");

    return;
}

