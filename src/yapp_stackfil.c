/*
 * @file yapp_stackfil.c
 * Program to stack multiple sub-band filterbank files to form a single
 *  filterbank file.
 *
 * @verbatim
 * Usage: yapp_stackfil [options] <data-file-0> ... <data-file-N-1>
 *     -h  --help                           Display this usage information
 *     -n  --nsamp <samples>                Number of samples read in one block
 *                                          (default is 4096 samples)
 *     -g  --graphics                       Turn on plotting
 *     -m  --colour-map <name>              Colour map for plotting
 *                                          (default is 'jet')
 *     -i  --invert                         Invert the background and foreground
 *                                          colours in plots
 *     -e  --non-interactive                Run in non-interactive mode
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2013.09.21
 */

#include "yapp.h"
#include "yapp_sigproc.h"   /* for SIGPROC filterbank file format support */
#include "colourmap.h"

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* PGPLOT device ID */
extern int g_iPGDev;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
float **g_ppfBuf = NULL;
float *g_pfOutBuf = NULL;
float *g_pfPlotBuf = NULL;
float *g_pfXAxis = NULL;
float *g_pfXAxisOld = NULL;
float *g_pfYAxis = NULL;

int main(int argc, char *argv[])
{
    FILE **ppFIn = NULL;
    FILE *pFOut = NULL;
    char *pcFileOut = NULL;
    int iNumBands = 0;
    char acFileOut[LEN_GENSTRING] = {0};
    int iFormat = DEF_FORMAT;
    YUM_t stYUM = {{0}};
    float *pafCenFreq = NULL;
    int *piChanPadding = NULL;
    int iNumChans = 0;
    int iBlockSize = DEF_SIZE_BLOCK;
    int iTotSampsPerBlock = 0;  /* iNumChans * iBlockSize */
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    float *pfSpectrum = NULL;
    int iNumReads = 0;
    int iTotNumReads = 0;
    int iReadBlockCount = 0;
    int iOffset = 0;
    char cIsLastBlock = YAPP_FALSE;
    int iRet = YAPP_RET_SUCCESS;
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    int iReadItems = 0;
    float fButX = 0.0;
    float fButY = 0.0;
    char cCurChar = 0;
    int iNumSamps = 0;
    int iDiff = 0;
    float fTemp = 0.0;
    FILE *pFTemp = NULL;
    int iInIdx = 0;
    int iOutIdx = 0;
    int iNumChansToSkip = 0;
    char cIsFirst = YAPP_TRUE;
    int i = 0;
    int j = 0;
    int k = 0;
    int l = 0;
    int m = 0;
    char acLabel[LEN_GENSTRING] = {0};
    char cHasGraphics = YAPP_FALSE;
    int iColourMap = DEF_CMAP;
    int iInvCols = YAPP_FALSE;
    char cIsNonInteractive = YAPP_FALSE;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hn:giev";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "nsamp",                  1, NULL, 'n' },
        { "graphics",               0, NULL, 'g' },
        { "invert",                 0, NULL, 'i' },
        { "non-interactive",        0, NULL, 'e' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 'n':   /* -n or --nsamp */
                /* set option */
                iBlockSize = atoi(optarg);
                /* validate - PGPLOT does not like iBlockSize = 1 */
                if (iBlockSize < 2)
                {
                    (void) fprintf(stderr,
                                   "ERROR: Number of samples must be > 1!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'g':   /* -g or --graphics */
                /* set option */
                cHasGraphics = YAPP_TRUE;
                break;

            case 'i':  /* -i or --invert */
                /* set option */
                iInvCols = YAPP_TRUE;
                break;

            case 'e':  /* -e or --non-interactive */
                /* set option */
                cIsNonInteractive = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* only one file - can't stack */
    iNumBands = argc - optind;
    if (iNumBands == 1)
    {
        (void) fprintf(stderr, "ERROR: Only one input file given!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* user input validation - check the file type for all input files */
    for (i = optind; i < argc; ++i)
    {
        /* determine the file type */
        iFormat = YAPP_GetFileType(argv[i]);
        if (YAPP_RET_ERROR == iFormat)
        {
            (void) fprintf(stderr,
                           "ERROR: File type determination failed!\n");
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        if (iFormat != YAPP_FORMAT_FIL)
        {
            (void) fprintf(stderr,
                           "ERROR: Invalid file type!\n");
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
    }

    /* read metadata */
    /* NOTE: it is assumed that all files correspond to a single observation.
             the only information taken from all files except the last one is
             the centre frequency. general metadata is read from the last
             file */
    /* allocate memory for the frequency array */
    pafCenFreq = (float *) YAPP_Malloc((size_t) iNumBands,
                                    sizeof(float),
                                    YAPP_FALSE);
    if (NULL == pafCenFreq)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    for (i = optind; i < argc; ++i)
    {
        (void) memset(&stYUM, '\0', sizeof(YUM_t));
        iRet = YAPP_ReadMetadata(argv[i], iFormat, &stYUM);
        if (iRet != YAPP_RET_SUCCESS)
        {
            (void) fprintf(stderr,
                           "ERROR: Reading metadata failed for file %s!\n",
                           argv[i]);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        pafCenFreq[i-optind] = stYUM.fFCentre;
    }

    /* convert sampling interval to seconds */
    dTSampInSec = stYUM.dTSamp / 1e3;

    iNumReads = (int) ceilf(((float) stYUM.iTimeSamps) / iBlockSize);
    iTotNumReads = iNumReads;

    /* read the number of channels per input band */
    iNumChans = stYUM.iNumChans;

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = iNumChans * iBlockSize;

    /* open the time series data files for reading */
    /* allocate memory for the file pointer array */
    ppFIn = (FILE **) YAPP_Malloc((size_t) iNumBands,
                                  sizeof(FILE *),
                                  YAPP_FALSE);
    if (NULL == ppFIn)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    for (i = optind; i < argc; ++i)
    {
        ppFIn[i-optind] = fopen(argv[i], "r");
        if (NULL == ppFIn[i-optind])
        {
            (void) fprintf(stderr,
                           "ERROR: Opening file %s failed! %s.\n",
                           argv[i],
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        /* skip the header */
        (void) fseek(ppFIn[i-optind], (long) stYUM.iHeaderLen, SEEK_SET);
    }

    /* sort the input files and centre frequency array in ascending frequency
       order */
    for (i = 0; i < iNumBands; ++i)
    {
        for (j = i; j < iNumBands; ++j)
        {
            if (pafCenFreq[j] < pafCenFreq[i])
            {
                /* swap centre frequencies */
                fTemp = pafCenFreq[i];
                pafCenFreq[i] = pafCenFreq[j];
                pafCenFreq[j] = fTemp;

                /* swap file handles */
                pFTemp = ppFIn[i];
                ppFIn[i] = ppFIn[j];
                ppFIn[j] = pFTemp;
            }
        }
    }

    /* allocate memory for the buffer pointer array */
    g_ppfBuf = (float **) YAPP_Malloc((size_t) iNumBands,
                                      sizeof(float *),
                                      YAPP_FALSE);
    if (NULL == g_ppfBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    /* allocate memory for the buffer */
    for (i = 0; i < iNumBands; ++i)
    {
        g_ppfBuf[i] = (float *) YAPP_Malloc((size_t) iNumChans * iBlockSize,
                                            sizeof(float),
                                            YAPP_FALSE);
        if (NULL == g_ppfBuf[i])
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation failed! %s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
    }

    if (1 == iNumReads)
    {
        cIsLastBlock = YAPP_TRUE;
    }

    /* open the time series data file for writing */
    pcFileOut = YAPP_GetFilenameFromPath(argv[optind]);
    (void) sprintf(acFileOut,
                   "%s.%s%s",
                   pcFileOut,
                   INFIX_STACK,
                   EXT_FIL);

    /* populate the YUM structure for output */
    stYUM.fFMin = pafCenFreq[0] - ((iNumChans / 2) * stYUM.fChanBW);
    /* calculate number of channels, and padding between bands, taking into
       account gaps, overlaps, and offsets */
    piChanPadding = (int *) YAPP_Malloc((size_t) iNumBands,
                                        sizeof(int),
                                        YAPP_TRUE);
    if (NULL == piChanPadding)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    stYUM.iNumChans = YAPP_CalcNumChans(iNumBands,
                                        pafCenFreq,
                                        iNumChans,
                                        stYUM.fChanBW,
                                        piChanPadding);
    /* TODO: this calculation does not match
       fFMax = pafCenFreq[iNumBands-1] + ((iNumChans / 2) * stYUM.fChanBW).
       consider padding? */
    stYUM.fFMax = stYUM.fFMin + (stYUM.iNumChans * stYUM.fChanBW);
    stYUM.fFCentre = stYUM.fFMin + (stYUM.fFMax - stYUM.fFMin) / 2;
    /* NOTE: min and max are centre frequencies of channels */
    stYUM.fBW = stYUM.fFMax - stYUM.fFMin + stYUM.fChanBW;
    stYUM.cIsBandFlipped = YAPP_FALSE;
    /* write metadata to disk */
    iFormat = YAPP_FORMAT_FIL;
    iRet = YAPP_WriteMetadata(acFileOut, iFormat, stYUM);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Writing metadata failed for file %s!\n",
                       acFileOut);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* open file for appending data */
    pFOut = fopen(acFileOut, "a");
    if (NULL == pFOut)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       acFileOut,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* open the PGPLOT graphics device */
    if (cHasGraphics)
    {
        g_iPGDev = cpgopen(PG_DEV);
        if (g_iPGDev <= 0)
        {
            (void) fprintf(stderr,
                           "ERROR: Opening graphics device %s failed!\n",
                           PG_DEV);
            (void) fclose(pFOut);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        /* set the background colour to white and the foreground colour to
           black, if user requires so */
        if (YAPP_TRUE == iInvCols)
        {
            cpgscr(0, 1.0, 1.0, 1.0);
            cpgscr(1, 0.0, 0.0, 0.0);
        }

        cpgsch(PG_CH);

        /* set up the plot's X-axis */
        g_pfXAxis = (float *) YAPP_Malloc((size_t) iBlockSize,
                                          sizeof(float),
                                          YAPP_FALSE);
        if (NULL == g_pfXAxis)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for X-axis failed! %s!\n",
                           strerror(errno));
            (void) fclose(pFOut);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        g_pfXAxisOld = (float *) YAPP_Malloc((size_t) iBlockSize,
                                             sizeof(float),
                                             YAPP_FALSE);
        if (NULL == g_pfXAxisOld)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for X-axis failed! %s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        /* set up the image plot's Y-axis (frequency) */
        g_pfYAxis = (float *) YAPP_Malloc(stYUM.iNumChans,
                                          sizeof(float),
                                          YAPP_FALSE);
        if (NULL == g_pfYAxis)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for Y-axis failed! %s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        for (i = 0; i < stYUM.iNumChans; ++i)
        {
            g_pfYAxis[i] = stYUM.fFMin + i * stYUM.fChanBW;
        }
    }

    /* allocate memory for the filterbank buffer */
    g_pfOutBuf = (float *) YAPP_Malloc((size_t) stYUM.iNumChans * iBlockSize,
                                       sizeof(float),
                                       YAPP_TRUE);
    if (NULL == g_pfOutBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for plot buffer failed! "
                       "%s!\n",
                       strerror(errno));
        (void) fclose(pFOut);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* allocate memory for the cpgimag() plotting buffer */
    g_pfPlotBuf = (float *) YAPP_Malloc((stYUM.iNumChans * iBlockSize),
                                        sizeof(float),
                                        YAPP_FALSE);
    if (NULL == g_pfPlotBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for plot buffer failed! "
                       "%s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    while (iNumReads > 0)
    {
        /* read data */
        (void) printf("\rReading data block %d of %d.",
                      iReadBlockCount + 1,
                      iTotNumReads);
        (void) fflush(stdout);
        for (i = 0; i < iNumBands; ++i)
        {
            iReadItems = YAPP_ReadData(ppFIn[i],
                                       g_ppfBuf[i],
                                       stYUM.fSampSize,
                                       iTotSampsPerBlock);
            if (YAPP_RET_ERROR == iReadItems)
            {
                (void) fprintf(stderr, "ERROR: Reading data failed!\n");
                (void) fclose(pFOut);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }

            if (iReadItems < iTotSampsPerBlock)
            {
                iDiff = iTotSampsPerBlock - iReadItems;

                /* reset remaining elements to '\0' */
                (void) memset((g_ppfBuf[0] + iReadItems),
                              '\0',
                              (sizeof(float) * iDiff));
            }

            /* calculate the number of time samples in the block - this may not
               be iBlockSize for the last block, and should be iBlockSize for
               all other blocks */
            iNumSamps = iReadItems / iNumChans;
        }
        --iNumReads;
        ++iReadBlockCount;

        /* zero the output buffer */
        (void) memset(g_pfOutBuf,
                      '\0',
                      sizeof(float) * stYUM.iNumChans * iBlockSize);

        /* construct filterbank data, taking into account gaps, overlaps, and
           offsets */
        for (i = 0; i < iNumSamps; ++i)
        {
            pfSpectrum = g_pfOutBuf + i * iNumBands;
            iOffset = 0;
            for (j = 0; j < iNumBands; ++j)
            {
                for (k = iNumChansToSkip; k < iNumChans; ++k)
                {
                    iInIdx = (i * iNumChans) + k;
                    iOutIdx = (i * stYUM.iNumChans) + (j * iNumChans)
                              + iOffset + (k - iNumChansToSkip);
                    pfSpectrum[iOutIdx] = g_ppfBuf[j][iInIdx];
                }
                if (piChanPadding[j] > 0)       /* gap */
                {
                    for (l = 0 ; l < piChanPadding[j]; ++l)
                    {
                        iOutIdx = (i * stYUM.iNumChans) + (j * iNumChans)
                                  + iOffset + k + l;
                        pfSpectrum[iOutIdx] = 0.0;
                    }
                    /* no channel-skipping needed */
                    iNumChansToSkip = 0;
                    iOffset += l;
                }
                else if (piChanPadding[j] < 0)  /* overlap */
                {
                    /* skip piChanPadding[j] channels in the next band */
                    iNumChansToSkip = piChanPadding[j];
                    break;
                }
                else                            /* exact match */
                {
                    /* no channel-skipping needed */
                    iNumChansToSkip = 0;
                }
            }
        }

        /* write summed data to file */
        (void) fwrite(g_pfOutBuf,
                      sizeof(float),
                      (long) stYUM.iNumChans * iNumSamps,
                      pFOut);

        if (cHasGraphics)
        {
            fDataMin = g_pfOutBuf[0];
            fDataMax = g_pfOutBuf[0];
            for (i = 0; i < stYUM.iNumChans * iNumSamps; ++i)
            {
                if (g_pfOutBuf[i] < fDataMin)
                {
                    fDataMin = g_pfOutBuf[i];
                }
                if (g_pfOutBuf[i] > fDataMax)
                {
                    fDataMax = g_pfOutBuf[i];
                }
            }

            #ifdef DEBUG
            (void) printf("Minimum value of data             : %g\n",
                          fDataMin);
            (void) printf("Maximum value of data             : %g\n",
                          fDataMax);
            #endif

            for (i = 0; i < iBlockSize; ++i)
            {
                g_pfXAxisOld[i] = g_pfXAxis[i];
                g_pfXAxis[i] = (float) (((iReadBlockCount - 1)
                                            * iBlockSize
                                            * dTSampInSec)
                                           + (i * dTSampInSec));
            }

            /* get the transpose of the two-dimensional array */
            i = 0;
            j = 0;
            k = 0;
            for (l = 0; l < iBlockSize; ++l)
            {
                pfSpectrum = g_pfOutBuf + l * stYUM.iNumChans;
                for (m = 0; m < stYUM.iNumChans; ++m)
                {
                    j = k + i * iBlockSize;
                    g_pfPlotBuf[j] = pfSpectrum[m];
                    ++i;
                }
                i = 0;
                ++k;
            }

            /* erase the previous x-axis */
            if (!cIsFirst && !cIsNonInteractive)   /* kludge */
            {
                cpgsvp(PG_2D_VP_ML, PG_2D_VP_MR, PG_2D_VP_MB, PG_2D_VP_MT);
                cpgswin(g_pfXAxisOld[0],
                        g_pfXAxisOld[iBlockSize-1],
                        stYUM.fFMin,
                        stYUM.fFMax);
            }
            cpgsci(0);      /* background */
            cpgaxis("N",
                    g_pfXAxisOld[0], stYUM.fFMin,
                    g_pfXAxisOld[iBlockSize-1], stYUM.fFMin,
                    g_pfXAxisOld[0], g_pfXAxisOld[iBlockSize-1],
                    0.0,
                    0,
                    0.5,
                    0.0,
                    0.5,
                    0.5,
                    0);
            cpgbox("CST", 0.0, 0, "CST", 0.0, 0);
            cIsFirst = YAPP_FALSE;
            cpgsci(PG_CI_DEF);
            Plot2D(g_pfPlotBuf, fDataMin, fDataMax,
                   g_pfXAxis, iBlockSize, dTSampInSec,
                   g_pfYAxis, stYUM.iNumChans, stYUM.fChanBW,
                   "Time - Start Time (s)", "Frequency (MHz)",
                   "Dynamic Spectrum",
                   iColourMap);

            /* display the plot number */
            /* TODO: bug - in maximized window, plot not proper  */
            (void) sprintf(acLabel, "%d / %d", iReadBlockCount, iTotNumReads);
            cpgmtxt("T", -1.5, 0.99, 1.0, acLabel);

            if (!(cIsLastBlock))
            {
                if (!(cIsNonInteractive))
                {
                    /* draw the 'next' and 'exit' buttons */
                    cpgsvp(PG_VP_BUT_ML, PG_VP_BUT_MR, PG_VP_BUT_MB, PG_VP_BUT_MT);
                    cpgswin(PG_BUT_L, PG_BUT_R, PG_BUT_B, PG_BUT_T);
                    cpgsci(PG_BUT_FILLCOL); /* set the fill colour */
                    cpgrect(PG_BUTNEXT_L, PG_BUTNEXT_R, PG_BUTNEXT_B, PG_BUTNEXT_T);
                    cpgrect(PG_BUTEXIT_L, PG_BUTEXIT_R, PG_BUTEXIT_B, PG_BUTEXIT_T);
                    cpgsci(0);  /* set colour index to white */
                    cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                    cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");

                    fButX = (PG_BUTNEXT_R - PG_BUTNEXT_L) / 2;
                    fButY = (PG_BUTNEXT_T - PG_BUTNEXT_B) / 2;

                    while (YAPP_TRUE)
                    {
                        iRet = cpgcurs(&fButX, &fButY, &cCurChar);
                        if (0 == iRet)
                        {
                            (void) fprintf(stderr,
                                           "WARNING: "
                                           "Reading cursor parameters failed!\n");
                            break;
                        }

                        if (((fButX >= PG_BUTNEXT_L) && (fButX <= PG_BUTNEXT_R))
                            && ((fButY >= PG_BUTNEXT_B) && (fButY <= PG_BUTNEXT_T)))
                        {
                            /* animate button click */
                            cpgsci(PG_BUT_FILLCOL);
                            cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                            cpgsci(0);  /* set colour index to white */
                            cpgtext(PG_BUTNEXT_CL_TEXT_L, PG_BUTNEXT_CL_TEXT_B, "Next");
                            (void) usleep(PG_BUT_CL_SLEEP);
                            cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                       colour */
                            cpgtext(PG_BUTNEXT_CL_TEXT_L, PG_BUTNEXT_CL_TEXT_B, "Next");
                            cpgsci(0);  /* set colour index to white */
                            cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                            cpgsci(1);  /* reset colour index to black */
                            (void) usleep(PG_BUT_CL_SLEEP);

                            break;
                        }
                        else if (((fButX >= PG_BUTEXIT_L) && (fButX <= PG_BUTEXIT_R))
                            && ((fButY >= PG_BUTEXIT_B) && (fButY <= PG_BUTEXIT_T)))
                        {
                            /* animate button click */
                            cpgsci(PG_BUT_FILLCOL);
                            cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");
                            cpgsci(0);  /* set colour index to white */
                            cpgtext(PG_BUTEXIT_CL_TEXT_L, PG_BUTEXIT_CL_TEXT_B, "Exit");
                            (void) usleep(PG_BUT_CL_SLEEP);
                            cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                       colour */
                            cpgtext(PG_BUTEXIT_CL_TEXT_L, PG_BUTEXIT_CL_TEXT_B, "Exit");
                            cpgsci(0);  /* set colour index to white */
                            cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");
                            cpgsci(1);  /* reset colour index to black */
                            (void) usleep(PG_BUT_CL_SLEEP);

                            (void) fclose(pFOut);
                            YAPP_CleanUp();
                            return YAPP_RET_SUCCESS;
                        }
                    }
                }
                else
                {
                    /* pause before erasing */
                    (void) usleep(PG_PLOT_SLEEP);
                }
            }
        }

        if (1 == iNumReads)
        {
            cIsLastBlock = YAPP_TRUE;
        }
    }

    (void) printf("DONE!\n");

    (void) fclose(pFOut);
    YAPP_CleanUp();

    return YAPP_RET_SUCCESS;
}


/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <data-file-0> ...<data-file-1>\n",
                  pcProgName);
    (void) printf("    -h  --help                          ");
    (void) printf("Display this usage information\n");
    (void) printf("    -n  --nsamp <samples>               ");
    (void) printf("Number of samples read in one block\n");
    (void) printf("                                        ");
    (void) printf("(default is 4096 samples)\n");
    (void) printf("    -g  --graphics                      ");
    (void) printf("Turn on plotting\n");
    (void) printf("    -m  --colour-map <name>             ");
    (void) printf("Colour map for plotting\n");
    (void) printf("                                        ");
    (void) printf("(default is 'jet')\n");
    (void) printf("    -i  --invert                        ");
    (void) printf("Invert background and foreground\n");
    (void) printf("                                        ");
    (void) printf("colours in plots\n");
    (void) printf("    -e  --non-interactive               ");
    (void) printf("Run in non-interactive mode\n");
    (void) printf("    -v  --version                       ");
    (void) printf("Display the version\n");

    return;
}

