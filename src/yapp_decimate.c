/*
 * @file yapp_decimate.c
 * Program to decimate (low-pass filter and downsample) data.
 *
 * @verbatim
 * Usage: yapp_decimate [options] <data-file>
 *     -h  --help                           Display this usage information
 *     -s  --skip <time>                    The length of data in seconds, to be
 *                                          skipped
 *                                          (default is 0 s)
 *     -p  --proc <time>                    The length of data in seconds, to be
 *                                          processed
 *                                          (default is all)
 *     -f  --out-chans <channels>           Number of channels in the output
 *     -t  --out-samps <samples>            Number of time samples in the output
 *     -w  --time-width <duration>          Width of boxcar window in milliseconds
 *     -b  --out-bits <bits>                Number of bits in output
 *                                          (default is same as input)
 *     -g  --graphics                       Turn on plotting
 *     -i  --invert                         Invert the background and foreground
 *                                          colours in plots
 *     -e  --non-interactive                Run in non-interactive mode
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2013.01.08
 */

#include "yapp.h"
#include "yapp_sigproc.h"   /* for SIGPROC filterbank file format support */

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* PGPLOT device ID */
extern int g_iPGDev;

/* data file */
extern FILE *g_pFData;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
float *g_pfBuf = NULL;
float *g_pfOutBuf = NULL;
unsigned char *g_pcOutBuf = NULL;
short int *g_piOutBuf = NULL;
float *g_pfXAxis = NULL;

int main(int argc, char *argv[])
{
    FILE *pFOut = NULL;
    char *pcFileData = NULL;
    char *pcFileOut = NULL;
    char acFileOut[LEN_GENSTRING] = {0};
    int iFormat = DEF_FORMAT;
    double dDataSkipTime = 0.0;
    double dDataProcTime = 0.0;
    YUM_t stYUM = {{0}};
    YUM_t stYUMOut = {{0}};
    int iTotSampsPerBlock = 0;  /* iNumChans * iBlockSize */
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    long lBytesToSkip = 0;
    long lBytesToProc = 0;
    int iTimeSampsToSkip = 0;
    int iTimeSampsToProc = 0;
    int iBlockSize = 0;
    int iReadBlockSize = 0;
    int iOutBlockSize = 0;
    int iNumReads = 0;
    int iReadBlockCount = 0;
    int iOutNumChans = 0;
    int iOutTimeSamps = 0;
    float fTimeWidth = 0.0;     /* in ms */
    int iOutNumBits = 0;
    char cIsLastBlock = YAPP_FALSE;
    int iRet = YAPP_RET_SUCCESS;
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    int iReadItems = 0;
    float fButX = 0.0;
    float fButY = 0.0;
    char cCurChar = 0;
    int iNumSamps = 0;
    int iSampsPerWin = 0;
    int iChansPerWin = 0;
    int iDiff = 0;
    int i = 0;
    char cHasGraphics = YAPP_FALSE;
    int iInvCols = YAPP_FALSE;
    char cIsNonInteractive = YAPP_FALSE;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hs:p:f:t:w:b:giev";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "skip",                   1, NULL, 's' },
        { "proc",                   1, NULL, 'p' },
        { "out-chans",              1, NULL, 'f' },
        { "out-samps",              1, NULL, 't' },
        { "time-width",             1, NULL, 'w' },
        { "out-bits",               1, NULL, 'b' },
        { "graphics",               0, NULL, 'g' },
        { "invert",                 0, NULL, 'i' },
        { "non-interactive",        0, NULL, 'e' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 's':   /* -s or --skip */
                /* set option */
                dDataSkipTime = atof(optarg);
                break;

            case 'p':   /* -p or --proc */
                /* set option */
                dDataProcTime = atof(optarg);
                break;

            case 'f':   /* -f or --out-chans */
                /* set option */
                iOutNumChans = atoi(optarg);
                break;

            case 't':   /* -t or --out-samps */
                /* set option */
                iOutTimeSamps = atoi(optarg);
                break;

            case 'w':   /* -w or --time-width */
                /* set option */
                fTimeWidth = atof(optarg);
                break;

            case 'b':   /* -b or --out-bits */
                /* set option */
                iOutNumBits = atoi(optarg);
                break;

            case 'g':   /* -g or --graphics */
                /* set option */
                cHasGraphics = YAPP_TRUE;
                break;

            case 'i':  /* -i or --invert */
                /* set option */
                iInvCols = YAPP_TRUE;
                break;

            case 'e':  /* -e or --non-interactive */
                /* set option */
                cIsNonInteractive = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileData = argv[optind];

    /* determine the file type */
    iFormat = YAPP_GetFileType(pcFileData);
    if (YAPP_RET_ERROR == iFormat)
    {
        (void) fprintf(stderr,
                       "ERROR: File type determination failed!\n");
        return YAPP_RET_ERROR;
    }
    if (!((YAPP_FORMAT_DTS_TIM == iFormat)
          || (YAPP_FORMAT_FIL == iFormat)))
    {
        (void) fprintf(stderr,
                       "ERROR: Invalid file type!\n");
        return YAPP_RET_ERROR;
    }

    if (((YAPP_FORMAT_FIL == iFormat)
        && ((0 == iOutNumChans)
            && (0 == iOutTimeSamps)
            && (0.0 == fTimeWidth)))
        || ((YAPP_FORMAT_DTS_TIM == iFormat)
            && ((0 == iOutTimeSamps)
                && (0.0 == fTimeWidth))))
    {
        (void) fprintf(stderr,
                       "ERROR: No decimation option given!\n");
        return YAPP_RET_ERROR;
    }

    if ((iOutTimeSamps != 0) && (fTimeWidth != 0.0))
    {
        (void) fprintf(stderr,
                       "WARNING: Both --out-samps/-t and --time-width/-w "
                       "given! Using --out-samps/-t.\n");
    }

    /* current support only for 4-bit integer, 8-bit integer, 16-bit integer,
       and 32-bit single-precision floating point values */
    if (iOutNumBits != 0)
    {
        if (!((YAPP_SAMPSIZE_4 == iOutNumBits)
              || (YAPP_SAMPSIZE_8 == iOutNumBits)
              || (YAPP_SAMPSIZE_16 == iOutNumBits)
              || (YAPP_SAMPSIZE_32 == iOutNumBits)))
        {
            (void) fprintf(stderr,
                           "ERROR: Unsupported output bits! %s only supports "
                           "4 (int), 8 (int), 16 (int), and "
                           "32 (float) bits, but request is for %d bits.\n",
                           pcProgName,
                           iOutNumBits);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
    }

    /* read metadata */
    iRet = YAPP_ReadMetadata(pcFileData, iFormat, &stYUM);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Reading metadata failed for file %s!\n",
                       pcFileData);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* current support only for 4-bit integer, 8-bit integer, 16-bit integer,
       and 32-bit single-precision floating point values */
    if (!((YAPP_SAMPSIZE_4 == stYUM.iNumBits)
          || (YAPP_SAMPSIZE_8 == stYUM.iNumBits)
          || (YAPP_SAMPSIZE_16 == stYUM.iNumBits)
          || (YAPP_SAMPSIZE_32 == stYUM.iNumBits)))
    {
        (void) fprintf(stderr,
                       "ERROR: Unsupported data type! %s only supports "
                       "4-bit ints, 8-bit ints, 16-bit ints, and "
                       "32-bit floats, but input data is %d bits.\n",
                       pcProgName,
                       stYUM.iNumBits);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* ensure that the number of channels is 1 for time series data */
    // TODO: think if this can be changed in yapp_common.c without breaking
    // anything
    if (YAPP_FORMAT_DTS_TIM == iFormat)
    {
        stYUM.iNumChans = 1;
    }

    /* convert sampling interval to seconds */
    dTSampInSec = stYUM.dTSamp / 1e3;

    /* calculate bytes to skip and read */
    if (0.0 == dDataProcTime)
    {
        dDataProcTime = (stYUM.iTimeSamps * dTSampInSec) - dDataSkipTime;
    }
    /* check if the input time duration is less than the length of the
       data */
    else if (dDataProcTime > (stYUM.iTimeSamps * dTSampInSec))
    {
        (void) fprintf(stderr,
                       "WARNING: Input time is longer than length of "
                       "data!\n");
    }

    lBytesToSkip = (long) floor(dDataSkipTime / dTSampInSec)
                                                    /* number of samples */
                          * stYUM.iNumChans
                          * stYUM.fSampSize;
    if (stYUM.fSampSize >= 2.0)
    {
        /* will be true for fSampSize = 0.5 and 1.0 */
        assert(0 == lBytesToSkip % (int) stYUM.fSampSize);
    }
    lBytesToProc = (long) floor(dDataProcTime / dTSampInSec)
                                                    /* number of samples */
                          * stYUM.iNumChans
                          * stYUM.fSampSize;
    if (stYUM.fSampSize >= 2.0)
    {
        /* will be true for fSampSize = 0.5 and 1.0 */
        assert(0 == lBytesToProc % (int) stYUM.fSampSize);
    }

    /* number of output time samples takes precedence over time width */
    if (iOutTimeSamps != 0)
    {
        if ((float) iOutTimeSamps > (float) stYUM.iTimeSamps / 2)
        {
            // TODO: check if outtimesamps = intimesamps, in which case,
            // continue with bitlength-changing
            (void) fprintf(stderr,
                           "WARNING: Requested output samples %d greater than "
                           "half the data samples %d! Setting output samples "
                           "to %d.\n",
                           iOutTimeSamps,
                           stYUM.iTimeSamps,
                           (int) floorf((float) stYUM.iTimeSamps / 2));
            iOutTimeSamps = (int) floorf((float) stYUM.iTimeSamps / 2);
        }

        /* NOTE: round down (use floorf()) to be safe */
        iSampsPerWin = (int) floorf((float) stYUM.iTimeSamps
                                    / iOutTimeSamps);
        fTimeWidth = (float) iSampsPerWin * stYUM.dTSamp;

        if ((int) floorf((float) stYUM.iTimeSamps / iSampsPerWin)
                != iOutTimeSamps)
        {
            (void) fprintf(stderr,
                           "WARNING: Requested %d output samples, getting %d "
                           "samples!\n",
                           iOutTimeSamps,
                           (int) floorf((float) stYUM.iTimeSamps
                                        / iSampsPerWin));
            /* not needed any more, but for consistency */
            iOutTimeSamps = (int) floorf((float) stYUM.iTimeSamps
                                         / iSampsPerWin);
        }
    }
    else if (fTimeWidth != 0.0)
    {
        /* calculate the number of time samples in one boxcar window */
        if (fTimeWidth < stYUM.dTSamp)
        {
            (void) fprintf(stderr,
                           "WARNING: Requested time window width %.10g ms is "
                           "less than sampling time %.10g ms; Adjusting "
                           "window width to sampling time!\n",
                           fTimeWidth,
                           stYUM.dTSamp);
            fTimeWidth = (float) stYUM.dTSamp;
        }
        else if (fTimeWidth >= (float) stYUM.iTimeSamps * stYUM.dTSamp / 2)
        {
            (void) fprintf(stderr,
                           "WARNING: Requested time window width %.10g ms "
                           "greater than half the data duration %.10g ms! "
                           "Setting time width to %.10g ms.\n",
                           fTimeWidth,
                           stYUM.iTimeSamps * stYUM.dTSamp,
                           (float) stYUM.iTimeSamps * stYUM.dTSamp / 2);
            fTimeWidth = (float) stYUM.iTimeSamps * stYUM.dTSamp / 2;
        }

        iSampsPerWin = (int) floorf(fTimeWidth / stYUM.dTSamp);

        /* not needed any more, but for consistency */
        iOutTimeSamps = (int) floorf((float) stYUM.iTimeSamps / iSampsPerWin);

        if ((float) iSampsPerWin * stYUM.dTSamp != fTimeWidth)
        {
            (void) fprintf(stderr,
                           "WARNING: Requested time window width %.10g ms, "
                           "getting %.10g ms!\n",
                           fTimeWidth,
                           (float) iSampsPerWin * stYUM.dTSamp);
            fTimeWidth = (float) iSampsPerWin * stYUM.dTSamp;
        }
    }
    else
    {
        /* this should not happen due to user input validation */
        assert(YAPP_TRUE);
    }

    //TODO: check if this warning is needed
    if (fTimeWidth > 1.0)   /* 1 ms */
    {
        fprintf(stderr,
                "WARNING: The chosen boxcar width may suppress "
                "pulsars with periods less than %g ms in the "
                "smoothed data!\n",
                fTimeWidth);
    }

    /* compute the block size - a large multiple of iSampsPerWin */
    iBlockSize = DEF_WINDOWS * iSampsPerWin;
    if (iBlockSize > MAX_SIZE_BLOCK)
    {
        iBlockSize = MAX_SIZE_BLOCK;
    }

    if (lBytesToSkip >= stYUM.lDataSizeTotal)
    {
        (void) fprintf(stderr,
                       "ERROR: Data to be skipped is greater than or equal to "
                       "the size of the file!\n");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if ((lBytesToSkip + lBytesToProc) > stYUM.lDataSizeTotal)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        lBytesToProc = stYUM.lDataSizeTotal - lBytesToSkip;
        (void) printf("Newly calculated size of data to be processed: %ld "
                      "bytes\n",
                      lBytesToProc);
    }

    iTimeSampsToSkip = (int) (lBytesToSkip / (stYUM.fSampSize));
    (void) printf("Skipping\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n",
                  lBytesToSkip,
                  stYUM.lDataSizeTotal,
                  iTimeSampsToSkip,
                  stYUM.iTimeSamps,
                  (iTimeSampsToSkip * dTSampInSec),
                  (stYUM.iTimeSamps * dTSampInSec));

    iTimeSampsToProc = (int) (lBytesToProc
                              / (stYUM.iNumChans * stYUM.fSampSize));
    /* change block size according to the number of samples to be processed */
    if (iTimeSampsToProc < iBlockSize)
    {
        iBlockSize = (int) ceil(dDataProcTime / dTSampInSec);
    }

    if (iBlockSize < iSampsPerWin)
    {
        iBlockSize = 2 * iSampsPerWin;
    }
    /* calculate the actual number of samples that will be processed in one
       iteration */
    iReadBlockSize = iBlockSize - (iSampsPerWin - 1);
    /* based on actual processed blocks */
    /* NOTE: needs to be ceilf() */
    iNumReads = (int) ceilf((float) (iTimeSampsToProc - (iSampsPerWin  - 1))
                            / iReadBlockSize);

    /* calculate the output block size - this is DEF_WINDOWS */
    iOutBlockSize = (int) roundf((float) iBlockSize / iSampsPerWin);

    if (YAPP_FORMAT_FIL == iFormat)
    {
        if ((float) iOutNumChans > (float) stYUM.iNumChans / 2)
        {
            // TODO: check if outnumchans = numchans, in which case,
            // continue with bitlength-changing
            (void) fprintf(stderr,
                           "WARNING: Requested output channels %d greater than "
                           "half the channels %d! Setting output channels "
                           "to %d.\n",
                           iOutNumChans,
                           stYUM.iNumChans,
                           (int) floorf((float) stYUM.iNumChans / 2));
            iOutNumChans = (int) floorf((float) stYUM.iNumChans / 2);
        }

        /* calculate the number of channels in one boxcar window */
        /* NOTE: round down (use floorf()) to be safe */
        iChansPerWin = (int) floorf((float) stYUM.iNumChans / iOutNumChans);

        if ((int) floorf((float) stYUM.iNumChans / iChansPerWin)
                != iOutNumChans)
        {
            (void) fprintf(stderr,
                           "WARNING: Requested %d output channels, getting %d "
                           "channels!\n",
                           iOutNumChans,
                           (int) floorf((float) stYUM.iNumChans
                                        / iChansPerWin));
            iOutNumChans = (int) floorf((float) stYUM.iNumChans
                                         / iChansPerWin);
        }
    }
    else
    {
        /* set this to 1 for YAPP_Decimate() to work */
        iChansPerWin = 1;
    }

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = stYUM.iNumChans * iBlockSize;

    (void) printf("Processing\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n"
                  "in %d reads with block size %d time samples...\n",
                  lBytesToProc,
                  stYUM.lDataSizeTotal,
                  iTimeSampsToProc,
                  stYUM.iTimeSamps,
                  (iTimeSampsToProc * dTSampInSec),
                  (stYUM.iTimeSamps * dTSampInSec),
                  iNumReads,
                  iReadBlockSize);

    if (YAPP_FORMAT_FIL == iFormat)
    {
        (void) printf("Boxcar window size is %d channels x %d time samples.\n",
                      iChansPerWin,
                      iSampsPerWin);
    }
    else
    {
        (void) printf("Boxcar window size is %d time samples.\n",
                      iSampsPerWin);
    }

    /* open the time series data file for reading */
    g_pFData = fopen(pcFileData, "r");
    if (NULL == g_pFData)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileData,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* allocate memory for the buffer, based on the number of channels and time
       samples */
    g_pfBuf = (float *) YAPP_Malloc((size_t) stYUM.iNumChans
                                             * iBlockSize
                                             * stYUM.fSampSize,
                                    sizeof(float),
                                    YAPP_FALSE);
    if (NULL == g_pfBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if (1 == iNumReads)
    {
        cIsLastBlock = YAPP_TRUE;
    }

    /* generate output file name */
    pcFileOut = YAPP_GetFilenameFromPath(pcFileData);
    if (YAPP_FORMAT_FIL == iFormat)
    {
        (void) sprintf(acFileOut,
                       //"%s.%s%g%s",
                       "%s.%s%s",
                       pcFileOut,
                       INFIX_SMOOTH,
                       //fTimeWidth,
                       EXT_FIL);
    }
    else
    {
        (void) sprintf(acFileOut,
                       "%s.%s%g%s",
                       pcFileOut,
                       INFIX_SMOOTH,
                       fTimeWidth,
                       EXT_TIM);
    }

    /* update output metadata */
    stYUMOut = stYUM;
    if (YAPP_FORMAT_FIL == iFormat)
    {
        stYUMOut.iNumChans = iOutNumChans;
        stYUMOut.iNumGoodChans = iOutNumChans;
        stYUMOut.fChanBW = stYUM.fChanBW * iChansPerWin;
        /* calculate the centre frequencies of the lowest and highest frequency
           channels */
        stYUMOut.fFMin = (stYUM.fFMin - stYUM.fChanBW / 2)
                            + (stYUMOut.fChanBW / 2);
        stYUMOut.fFMax = stYUMOut.fFMin
                            + (stYUMOut.iNumChans - 1) * stYUMOut.fChanBW;
        /* calculate bandwidth and centre frequency */
        /* NOTE: max and min are the _centre_ frequencies of the bins, so the
                 total bandwidth would be (max+chanbw/2)-(min-chanbw/2) */
        stYUMOut.fBW = (stYUMOut.fFMax - stYUMOut.fFMin) + stYUMOut.fChanBW;
        stYUMOut.fFCentre = (stYUMOut.fFMin - stYUM.fChanBW / 2)
                                + (stYUMOut.fBW / 2);
    }
    stYUMOut.dTSamp = stYUM.dTSamp * iSampsPerWin;
    stYUMOut.iTimeSamps = stYUM.iTimeSamps / iSampsPerWin;
    /* set output bits */
    if (iOutNumBits != 0)
    {
        stYUMOut.iNumBits = iOutNumBits;
        stYUMOut.fSampSize = (float) iOutNumBits / YAPP_BYTE2BIT_FACTOR; 
    }

    //TODO: check if anything else needs to be copied from styum to styumout
    /* write metadata to the output file */
    iRet = YAPP_WriteMetadata(acFileOut, iFormat, stYUMOut);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Writing metadata failed for file %s!\n",
                       acFileOut);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* open the output file for writing */
    pFOut = fopen(acFileOut, "a");
    if (NULL == pFOut)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       acFileOut,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* skip the header */
    (void) fseek(g_pFData, (long) stYUM.iHeaderLen, SEEK_SET);
    /* skip data, if any are to be skipped */
    (void) fseek(g_pFData, lBytesToSkip, SEEK_CUR);

    /* open the PGPLOT graphics device */
    if (cHasGraphics)
    {
        if (iFormat != YAPP_FORMAT_FIL)
        {
            g_iPGDev = cpgopen(PG_DEV);
            if (g_iPGDev <= 0)
            {
                (void) fprintf(stderr,
                               "ERROR: Opening graphics device %s failed!\n",
                               PG_DEV);
                (void) fclose(pFOut);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }

            /* set the background colour to white and the foreground colour to
               black, if user requires so */
            if (YAPP_TRUE == iInvCols)
            {
                cpgscr(0, 1.0, 1.0, 1.0);
                cpgscr(1, 0.0, 0.0, 0.0);
            }

            cpgsubp(1, 2);
            cpgsch(PG_CH_2P);

            /* set up the plot's X-axis */
            g_pfXAxis = (float *) YAPP_Malloc(iBlockSize,
                                              sizeof(float),
                                              YAPP_FALSE);
            if (NULL == g_pfXAxis)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for X-axis failed! %s!\n",
                               strerror(errno));
                (void) fclose(pFOut);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
        }
        else
        {
            (void) fprintf(stderr,
                           "WARNING: Plotting is not supported for .fil files!\n");
        }
    }

    /* allocate memory for the output buffer */
    g_pfOutBuf = (float *) YAPP_Malloc((size_t) iOutNumChans
                                                * iOutBlockSize
                                                * stYUM.fSampSize, 
                                       sizeof(char),
                                       YAPP_FALSE);
    if (NULL == g_pfOutBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for buffer failed! "
                       "%s!\n",
                       strerror(errno));
        (void) fclose(pFOut);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    switch (stYUMOut.iNumBits)
    {
        case YAPP_SAMPSIZE_4:
            /* allocate memory for the output buffer */
            g_pcOutBuf = (unsigned char *) YAPP_Malloc((size_t) iOutNumChans
                                                       * iOutBlockSize
                                                       / 2,
                                                       sizeof(unsigned char),
                                                       YAPP_FALSE);
            if (NULL == g_pcOutBuf)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for buffer failed! "
                               "%s!\n",
                               strerror(errno));
                (void) fclose(pFOut);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            break;

        case YAPP_SAMPSIZE_8:
            /* allocate memory for the output buffer */
            g_pcOutBuf = (unsigned char *) YAPP_Malloc((size_t) iOutNumChans
                                                       * iOutBlockSize,
                                                       sizeof(unsigned char),
                                                       YAPP_FALSE);
            if (NULL == g_pcOutBuf)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for buffer failed! "
                               "%s!\n",
                               strerror(errno));
                (void) fclose(pFOut);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            break;

        case YAPP_SAMPSIZE_16:
            /* allocate memory for the output buffer */
            g_piOutBuf = (short int *) YAPP_Malloc((size_t) iOutNumChans
                                                            * iOutBlockSize,
                                                   sizeof(short int),
                                                   YAPP_FALSE);
            if (NULL == g_piOutBuf)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for buffer failed! "
                               "%s!\n",
                               strerror(errno));
                (void) fclose(pFOut);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            break;

        default:
            /* this should never happen because of input validation */
            assert(YAPP_TRUE);
    }

    while (iNumReads > 0)
    {
        /* read data */
        (void) printf("\rReading data block %d.", iReadBlockCount);
        (void) fflush(stdout);
        iReadItems = YAPP_ReadData(g_pFData,
                                   g_pfBuf,
                                   stYUM.fSampSize,
                                   iTotSampsPerBlock);
        if (YAPP_RET_ERROR == iReadItems)
        {
            (void) fprintf(stderr, "ERROR: Reading data failed!\n");
            (void) fclose(pFOut);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        --iNumReads;
        ++iReadBlockCount;

        //TODO: check if this can be replaced with cIsLastBlock
        if ((iReadItems < iTotSampsPerBlock)    /* usually, the last block */
            || (0 == iNumReads))                /* definitely the last block */
        {
            iDiff = (stYUM.iNumChans * iBlockSize) - iReadItems;

            /* reset remaining elements to '\0' */
            (void) memset((g_pfBuf + iReadItems),
                          '\0',
                          (sizeof(float) * iDiff));

            iOutBlockSize = iOutTimeSamps
                                - ((iReadBlockCount - 1) * iOutBlockSize);
        }

        /* calculate the number of time samples in the block - this may not
           be iBlockSize for the last block, and should be iBlockSize for
           all other blocks */
        iNumSamps = iReadItems / stYUM.iNumChans;
        if (!cIsLastBlock)
        {
            assert(iNumSamps == iBlockSize);
        }

        /* decimate data */
        YAPP_Decimate(iFormat,
                      g_pfBuf,
                      iNumSamps,
                      iSampsPerWin,
                      stYUM.iNumChans,
                      iChansPerWin,
                      g_pfOutBuf,
                      iOutNumChans);

        /* requantize float to original/specified number of bits */
        switch (stYUMOut.iNumBits)
        {
            case YAPP_SAMPSIZE_4:
                YAPP_Float2Nibble(g_pfOutBuf,
                                  iOutNumChans * iOutBlockSize,
                                  stYUM.fMin,
                                  stYUM.fMax,
                                  g_pcOutBuf);
                /* write decimated data to file */
                (void) fwrite(g_pcOutBuf,
                              sizeof(unsigned char),
                              (long) iOutBlockSize * iOutNumChans / 2,
                              pFOut);
                break;

            case YAPP_SAMPSIZE_8:
                YAPP_Float2Byte(g_pfOutBuf,
                                iOutNumChans * iOutBlockSize,
                                stYUM.fMin,
                                stYUM.fMax,
                                g_pcOutBuf);
                /* write decimated data to file */
                (void) fwrite(g_pcOutBuf,
                              sizeof(unsigned char),
                              (long) iOutBlockSize * iOutNumChans,
                              pFOut);
                break;

            case YAPP_SAMPSIZE_16:
                YAPP_Float2Short(g_pfOutBuf,
                                iOutNumChans * iOutBlockSize,
                                stYUM.fMin,
                                stYUM.fMax,
                                g_piOutBuf);
                /* write decimated data to file */
                (void) fwrite(g_piOutBuf,
                              sizeof(short),
                              (long) iOutBlockSize * iOutNumChans,
                              pFOut);
                break;

            case YAPP_SAMPSIZE_32:
                /* write decimated data to file */
                (void) fwrite(g_pfOutBuf,
                              sizeof(float),
                              (long) iOutBlockSize * iOutNumChans,
                              pFOut);
                break;

            default:
                /* this should never happen because of input validation */
                assert(YAPP_TRUE);
        }

        if (iNumReads != 1)
        {
            /* set the file position to rewind by (iSampsPerWin - 1) time samples,
               and the appropriate number of channels */
            (void) fseek(g_pFData,
                         -((iSampsPerWin - 1)
                             * stYUM.iNumChans 
                             * stYUM.fSampSize
                             * sizeof(char)),
                         SEEK_CUR);
        }
        else
        {
            /* last-but-one block. need to rewind such that there is
               iSampsPerWin samples in the block */
            (void) fseek(g_pFData,
                         -((iSampsPerWin - 1)
                             * stYUM.iNumChans 
                             * stYUM.fSampSize
                             * sizeof(char)),
                         SEEK_CUR);
        }

        if (iFormat != YAPP_FORMAT_FIL)
        {
            if (cHasGraphics)
            {
                /* use a separate plotting buffer so that the x-axes for both
                   before and after plots are equivalent */
                float* pfPlotBuf = g_pfBuf + (iSampsPerWin / 2);
                fDataMin = pfPlotBuf[0];
                fDataMax = pfPlotBuf[0];
                for (i = 0; i < iReadBlockSize; ++i)
                {
                    if (pfPlotBuf[i] < fDataMin)
                    {
                        fDataMin = pfPlotBuf[i];
                    }
                    if (pfPlotBuf[i] > fDataMax)
                    {
                        fDataMax = pfPlotBuf[i];
                    }
                }

                #ifdef DEBUG
                (void) printf("Minimum value of data             : %g\n",
                              fDataMin);
                (void) printf("Maximum value of data             : %g\n",
                              fDataMax);
                #endif

                cpgpanl(1, 1);
                /* erase just before plotting, to reduce flicker */
                cpgeras();
                for (i = 0; i < iReadBlockSize; ++i)
                {
                    g_pfXAxis[i] = (float) (dDataSkipTime
                                            + (((iReadBlockCount - 1)
                                                * iReadBlockSize
                                                * dTSampInSec)
                                               + (i * dTSampInSec)));
                }

                cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
                cpgswin(g_pfXAxis[0],
                        g_pfXAxis[iReadBlockSize-1],
                        fDataMin,
                        fDataMax);
                cpglab("Time - Start Time (s)", "", "Before Smoothing");
                cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
                cpgsci(PG_CI_PLOT);
                cpgline(iReadBlockSize, g_pfXAxis, pfPlotBuf);
                cpgsci(PG_CI_DEF);

                fDataMin = g_pfOutBuf[0];
                fDataMax = g_pfOutBuf[0];
                for (i = 0; i < (iNumSamps - (iSampsPerWin - 1)); ++i)
                {
                    if (g_pfOutBuf[i] < fDataMin)
                    {
                        fDataMin = g_pfOutBuf[i];
                    }
                    if (g_pfOutBuf[i] > fDataMax)
                    {
                        fDataMax = g_pfOutBuf[i];
                    }
                }

                #ifdef DEBUG
                (void) printf("Minimum value of data             : %g\n",
                              fDataMin);
                (void) printf("Maximum value of data             : %g\n",
                              fDataMax);
                #endif

                cpgpanl(1, 2);
                /* erase just before plotting, to reduce flicker */
                cpgeras();
                for (i = 0; i < iReadBlockSize; ++i)
                {
                    g_pfXAxis[i] = (float) (dDataSkipTime
                                            + (((iReadBlockCount - 1)
                                                * iReadBlockSize
                                                * dTSampInSec)
                                               + (i * dTSampInSec)));
                }

                cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
                cpgswin(g_pfXAxis[0],
                        g_pfXAxis[iReadBlockSize-1],
                        fDataMin,
                        fDataMax);
                cpglab("Time - Start Time (s)", "", "After Smoothing");
                cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
                cpgsci(PG_CI_PLOT);
                cpgline(iReadBlockSize, g_pfXAxis, g_pfOutBuf);
                cpgsci(PG_CI_DEF);

                if (!(cIsLastBlock))
                {
                    if (!(cIsNonInteractive))
                    {
                        /* draw the 'next' and 'exit' buttons */
                        cpgsvp(PG_VP_BUT_ML, PG_VP_BUT_MR, PG_VP_BUT_MB, PG_VP_BUT_MT);
                        cpgswin(PG_BUT_L, PG_BUT_R, PG_BUT_B, PG_BUT_T);
                        cpgsci(PG_BUT_FILLCOL); /* set the fill colour */
                        cpgrect(PG_BUTNEXT_L, PG_BUTNEXT_R, PG_BUTNEXT_B, PG_BUTNEXT_T);
                        cpgrect(PG_BUTEXIT_L, PG_BUTEXIT_R, PG_BUTEXIT_B, PG_BUTEXIT_T);
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                        cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");

                        fButX = (PG_BUTNEXT_R - PG_BUTNEXT_L) / 2;
                        fButY = (PG_BUTNEXT_T - PG_BUTNEXT_B) / 2;

                        while (YAPP_TRUE)
                        {
                            iRet = cpgcurs(&fButX, &fButY, &cCurChar);
                            if (0 == iRet)
                            {
                                (void) fprintf(stderr,
                                               "WARNING: "
                                               "Reading cursor parameters failed!\n");
                                break;
                            }

                            if (((fButX >= PG_BUTNEXT_L) && (fButX <= PG_BUTNEXT_R))
                                && ((fButY >= PG_BUTNEXT_B) && (fButY <= PG_BUTNEXT_T)))
                            {
                                /* animate button click */
                                cpgsci(PG_BUT_FILLCOL);
                                cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                                cpgsci(0);  /* set colour index to white */
                                cpgtext(PG_BUTNEXT_CL_TEXT_L, PG_BUTNEXT_CL_TEXT_B, "Next");
                                (void) usleep(PG_BUT_CL_SLEEP);
                                cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                           colour */
                                cpgtext(PG_BUTNEXT_CL_TEXT_L, PG_BUTNEXT_CL_TEXT_B, "Next");
                                cpgsci(0);  /* set colour index to white */
                                cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                                cpgsci(1);  /* reset colour index to black */
                                (void) usleep(PG_BUT_CL_SLEEP);

                                break;
                            }
                            else if (((fButX >= PG_BUTEXIT_L) && (fButX <= PG_BUTEXIT_R))
                                && ((fButY >= PG_BUTEXIT_B) && (fButY <= PG_BUTEXIT_T)))
                            {
                                /* animate button click */
                                cpgsci(PG_BUT_FILLCOL);
                                cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");
                                cpgsci(0);  /* set colour index to white */
                                cpgtext(PG_BUTEXIT_CL_TEXT_L, PG_BUTEXIT_CL_TEXT_B, "Exit");
                                (void) usleep(PG_BUT_CL_SLEEP);
                                cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                           colour */
                                cpgtext(PG_BUTEXIT_CL_TEXT_L, PG_BUTEXIT_CL_TEXT_B, "Exit");
                                cpgsci(0);  /* set colour index to white */
                                cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");
                                cpgsci(1);  /* reset colour index to black */
                                (void) usleep(PG_BUT_CL_SLEEP);

                                (void) fclose(pFOut);
                                YAPP_CleanUp();
                                return YAPP_RET_SUCCESS;
                            }
                        }
                    }
                    else
                    {
                        /* pause before erasing */
                        (void) usleep(PG_PLOT_SLEEP);
                    }
                }
            }
        }

        /* reset output buffer to zero. not necessary, but to be safe. */
        (void) memset(g_pfOutBuf,
                      '\0',
                      (sizeof(float) * iOutBlockSize * iOutNumChans));

        if (1 == iNumReads)
        {
            /* next block is the last block */
            cIsLastBlock = YAPP_TRUE;
        }
    }

    (void) printf("DONE!\n");

    (void) fclose(pFOut);
    YAPP_CleanUp();

    return YAPP_RET_SUCCESS;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <data-file>\n",
                  pcProgName);
    (void) printf("    -h  --help                          ");
    (void) printf("Display this usage information\n");
    (void) printf("    -s  --skip <time>                   ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                        ");
    (void) printf("skipped\n");
    (void) printf("                                        ");
    (void) printf("(default is 0 s)\n");
    (void) printf("    -p  --proc <time>                   ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                        ");
    (void) printf("processed\n");
    (void) printf("                                        ");
    (void) printf("(default is all)\n");
    (void) printf("    -f  --out-chans <channels>          ");
    (void) printf("Frequency decimation factor\n");
    (void) printf("    -t  --out-samps <samples>           ");
    (void) printf("Time decimation factor\n");
    (void) printf("    -w  --time-width <width>            ");
    (void) printf("Width of boxcar window in milliseconds\n");
    (void) printf("    -b  --out-bits <bits>               ");
    (void) printf("Number of bits in output\n");
    (void) printf("                                        ");
    (void) printf("(default is same as input)\n");
    (void) printf("    -g  --graphics                      ");
    (void) printf("Turn on plotting\n");
    (void) printf("    -i  --invert                        ");
    (void) printf("Invert background and foreground\n");
    (void) printf("                                        ");
    (void) printf("colours in plots\n");
    (void) printf("    -e  --non-interactive               ");
    (void) printf("Run in non-interactive mode\n");
    (void) printf("    -v  --version                       ");
    (void) printf("Display the version\n");

    return;
}

