/*
 * @file yapp_fold.c
 * Program to fold filterbank or dedispersed time series data at a specified
 *  period.
 *
 * @verbatim
 * Usage: yapp_fold [options] <data-file>
 *     -h  --help                           Display this usage information
 *     -s  --skip <time>                    The length of data in seconds, to be
 *                                          skipped
 *                                          (default is 0 s)
 *     -p  --proc <time>                    The length of data in seconds, to be
 *                                          processed
 *                                          (default is all)
 *     -t  --period <period>                Folding period in milliseconds
 *     -w  --waterfall <numpulses>          Show a waterfall plot (pulse number
 *                                          versus phase) instead of a folded
 *                                          profile
 *     -x  --waterfallgs <numpulses>        Show a grayscale waterfall plot
 *                                          (pulse number versus phase) instead
 *                                          of a folded profile
 *     -m  --colour-map <name>              Colour map for plotting
 *                                          (default is 'jet')
 *     -f  --file                           Plot to file, instead of to screen
 *     -i  --invert                         Invert the background and foreground
 *                                          colours in plots
 *     -e  --non-interactive                Run in non-interactive mode
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2012.10.23
 */

#include "yapp.h"
#include "yapp_sigproc.h"   /* for SIGPROC filterbank file format support */
#include "colourmap.h"

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* PGPLOT device ID */
extern int g_iPGDev;

/* data file */
extern FILE *g_pFData;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
char *g_pcIsTimeGood = NULL;
float *g_pfBuf = NULL;
float *g_pfProfBuf = NULL;
float *g_pf2DProfBuf = NULL;
float *g_pfPlotBuf = NULL;
double *g_pdPhase = NULL;
float *g_pfPhase = NULL;
float *g_pfYAxis = NULL;

int main(int argc, char *argv[])
{
    char *pcFileData = NULL;
    FILE *pFProfile = NULL;
    int iFormat = DEF_FORMAT;
    double dDataSkipTime = 0.0;
    double dDataProcTime = 0.0;
    YUM_t stYUM = {{0}};
    double dTNextBF = 0.0;
    float *pfTimeSectGain = NULL;
    int iBlockSize = DEF_SIZE_BLOCK;
    int iTotSampsPerBlock = 0;
    float fStatBW = 0.0;
    float fNoiseRMS = 0.0;
    double dNumSigmas = 0.0;
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    double dTNow = 0.0;
    int iTimeSect = 0;
    int iBadTimeSect = 0;
    char cIsInBadTimeRange = YAPP_FALSE;
    float *pfSpectrum = NULL;
    float *pfProfSpec = NULL;
    long lBytesToSkip = 0;
    long lBytesToProc = 0;
    int iTimeSampsToSkip = 0;
    int iTimeSampsToProc = 0;
    int iNumReads = 0;
    int iTotNumReads = 0;
    int iReadBlockCount = 0;
    char cIsLastBlock = YAPP_FALSE;
    int iRet = YAPP_RET_SUCCESS;
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    float fDataMinOld = 0.0;
    float fDataMaxOld = 0.0;
    char cIsFirst = YAPP_TRUE;
    int iReadItems = 0;
    float fButX = 0.0;
    float fButY = 0.0;
    char cCurChar = 0;
    int iNumSamps = 0;
    double dPeriod = 0.0;
    double dPhase = 0.0;
    double dTurn = 0.0;
    double dPhaseStep = 0.0;
    int iSampsPerPeriod = 0;
    double dSampsPerPeriodFrac = 0.0;
    int iPaddingCadence = 0;
    int iTotalPulses = 0;
    int iWaterfallType = 0;
    //double dPNorm = 0.0;
    //float fAcc = -1000.0;
    double dTime = 0.0;
    long int lSampCount = 0;
    float fMeanNoise = 0.0;
    float fRMSNoise = 0.0;
    int iNumPulses = 0;
    int iDiff = 0;
    int i = 0;
    int j = 0;
    int k = 0;
    int l = 0;
    int m = 0;
    char acLabel[LEN_GENSTRING] = {0};
    int iColourMap = DEF_CMAP;
    char cPlotToFile = YAPP_FALSE;
    char *pcFilename = NULL;
    char acDev[LEN_GENSTRING] = {0};
    char acFileProf[LEN_GENSTRING] = {0};
    int iInvCols = YAPP_FALSE;
    char cIsNonInteractive = YAPP_FALSE;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hs:p:t:w:x:m:fiev";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "skip",                   1, NULL, 's' },
        { "proc",                   1, NULL, 'p' },
        { "period",                 1, NULL, 't' },
        { "waterfall",              1, NULL, 'w' },
        { "waterfallgs",            1, NULL, 'x' },
        { "colour-map",             1, NULL, 'm' },
        { "file",                   0, NULL, 'f' },
        { "invert",                 0, NULL, 'i' },
        { "non-interactive",        0, NULL, 'e' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 's':   /* -s or --skip */
                /* set option */
                dDataSkipTime = atof(optarg);
                break;

            case 'p':   /* -p or --proc */
                /* set option */
                dDataProcTime = atof(optarg);
                break;

            case 't':   /* -t or --period */
                /* set option */
                dPeriod = atof(optarg);
                break;

            case 'w':   /* -w or --waterfall */
                /* set option */
                iNumPulses = atoi(optarg);
                iWaterfallType = PLOT_WATERFALL;
                /* validate - PGPLOT does not like iNumPulses = 1 */
                if (iNumPulses < 2)
                {
                    (void) fprintf(stderr,
                                   "ERROR: Number of waterfalled pulses must "
                                   "be > 1!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'x':   /* -x or --wfallgs */
                /* set option */
                iNumPulses = atoi(optarg);
                iWaterfallType = PLOT_WATERFALL_GS;
                /* validate - PGPLOT does not like iNumPulses = 1 */
                if (iNumPulses < 2)
                {
                    (void) fprintf(stderr,
                                   "ERROR: Number of waterfalled pulses must "
                                   "be > 1!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'm':   /* -m or --colour-map */
                /* set option */
                iColourMap = GetColourMapFromName(optarg);
                break;

            case 'f':   /* -f or --file */
                /* set option */
                cPlotToFile = YAPP_TRUE;
                break;

            case 'i':  /* -i or --invert */
                /* set option */
                iInvCols = YAPP_TRUE;
                break;

            case 'e':  /* -e or --non-interactive */
                /* set option */
                cIsNonInteractive = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* user input validation */
    if (0.0 == dPeriod)
    {
        (void) fprintf(stderr, "ERROR: Folding period not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileData = argv[optind];

    /* determine the file type */
    iFormat = YAPP_GetFileType(pcFileData);
    if (YAPP_RET_ERROR == iFormat)
    {
        (void) fprintf(stderr,
                       "ERROR: File type determination failed!\n");
        return YAPP_RET_ERROR;
    }
    if (!((YAPP_FORMAT_FIL == iFormat)
          || (YAPP_FORMAT_SPEC == iFormat)
          || (YAPP_FORMAT_DTS_TIM == iFormat)
          || (YAPP_FORMAT_DTS_DAT == iFormat)))
    {
        (void) fprintf(stderr,
                       "ERROR: Invalid file type!\n");
        return YAPP_RET_ERROR;
    }

    /* user input validation */
    if (((YAPP_FORMAT_FIL == iFormat) || (YAPP_FORMAT_SPEC == iFormat))
        && (iWaterfallType != 0))
    {
        (void) fprintf(stderr,
                       "ERROR: "
                       "Unsupported file type for waterfall plots!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* read metadata */
    iRet = YAPP_ReadMetadata(pcFileData, iFormat, &stYUM);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Reading metadata failed for file %s!\n",
                       pcFileData);
        return YAPP_RET_ERROR;
    }
    /* kludge: the rest of the code expects stYUM.iNumChans = 1 for time series
       data, so make it 1 */
    if ((YAPP_FORMAT_DTS_TIM == iFormat)
        || (YAPP_FORMAT_DTS_DAT == iFormat))
    {
        stYUM.iNumChans = 1;
    }

    /* convert sampling interval to seconds */
    dTSampInSec = stYUM.dTSamp / 1e3;

    /* copy next beam-flip time */
    dTNextBF = stYUM.dTNextBF;

    /* calculate bytes to skip and read */
    if (0.0 == dDataProcTime)
    {
        dDataProcTime = (stYUM.iTimeSamps * dTSampInSec) - dDataSkipTime;
    }
    /* check if the input time duration is less than the length of the
       data */
    else if (dDataProcTime > (stYUM.iTimeSamps * dTSampInSec))
    {
        (void) fprintf(stderr,
                       "WARNING: Input time is longer than length of "
                       "data!\n");
    }

    lBytesToSkip = (long) floor((dDataSkipTime / dTSampInSec)
                                                    /* number of samples */
                           * stYUM.iNumChans
                           * stYUM.fSampSize);
    lBytesToProc = (long) floor((dDataProcTime / dTSampInSec)
                                                    /* number of samples */
                           * stYUM.iNumChans
                           * stYUM.fSampSize);

    /* calculate the number of bins in one profile */
    /* TODO: take care of drift due to rounding */
    //iSampsPerPeriod = (int) floor(dPeriod / stYUM.dTSamp);
    iSampsPerPeriod = (int) ceil(dPeriod / stYUM.dTSamp);
    dSampsPerPeriodFrac = (dPeriod / stYUM.dTSamp) - floor(dPeriod / stYUM.dTSamp);
    iPaddingCadence = ((int) ((double) 1 / dSampsPerPeriodFrac));
    iTotalPulses = (int) ceil((double) stYUM.iTimeSamps / iSampsPerPeriod);

    /* compute the block size - a large multiple of iSampsPerPeriod */
    if (0 == iWaterfallType)
    {
        iBlockSize = DEF_FOLD_PULSES * iSampsPerPeriod;
    }
    else
    {
        iBlockSize = iNumPulses * iSampsPerPeriod;
        if (iNumPulses > iTotalPulses)
        {
            (void) printf("WARNING: Total number of pulses in data less than "
                          "requested number! Adjusting number of pulses to be "
                          "folded to %d.\n", iTotalPulses);
            iNumPulses = iTotalPulses;
            iBlockSize = iNumPulses * iSampsPerPeriod;
        }
    }
    if (iBlockSize > MAX_SIZE_BLOCK_FOLD)
    {
        int iNumFold = (int) floor((double) MAX_SIZE_BLOCK_FOLD
                                   / iSampsPerPeriod);
        /* TODO: check for isampsperperiod > maxsizeblock */
        /* TODO: might want to normalize by iNumFold instead of DEF_FOLD_PULSES */
        iBlockSize = iNumFold * iSampsPerPeriod;
     //   printf("ispp = %d, inf = %d, ibs = %d, inp = %d\n", iSampsPerPeriod, iNumFold, iBlockSize, iNumPulses);
        if (iNumPulses != 0)
        {
            iNumPulses = iNumFold;
        }
        (void) printf("WARNING: Block size greater than maximum allowed! "
                      "Adjusting block size to %d.\n", iBlockSize);
    }

    /* if lBytesToSkip is not a multiple of the block size, make it one */
    if (((float) lBytesToSkip / iBlockSize) - (lBytesToSkip / iBlockSize) != 0)
    {
        (void) printf("WARNING: Bytes to skip not a multiple of block size! ");
        lBytesToSkip -= (((float) lBytesToSkip / iBlockSize)
                         - (lBytesToSkip / iBlockSize)) * iBlockSize;
        (void) printf("Newly calculated size of data to be skipped: %ld "
                      "bytes\n",
                      lBytesToSkip);
    }

    if (lBytesToSkip >= stYUM.lDataSizeTotal)
    {
        (void) fprintf(stderr,
                       "ERROR: Data to be skipped is greater than or equal to "
                       "the size of the file!\n");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if ((lBytesToSkip + lBytesToProc) > stYUM.lDataSizeTotal)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        lBytesToProc = stYUM.lDataSizeTotal - lBytesToSkip;
        dDataProcTime = ((double) lBytesToProc * dTSampInSec)
                        / (stYUM.iNumChans * stYUM.fSampSize);
        (void) printf("Newly calculated size of data to be processed: %ld "
                      "bytes\n",
                      lBytesToProc);
    }

    /* change block size according to the number of samples to be processed */
    if ((long) iBlockSize > lBytesToProc)
    {
        iBlockSize = (int) ceil(dDataProcTime / dTSampInSec);
    }

    iTimeSampsToSkip = (int) (lBytesToSkip
                              / (stYUM.iNumChans * stYUM.fSampSize));
    (void) printf("Skipping\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n",
                  lBytesToSkip,
                  stYUM.lDataSizeTotal,
                  iTimeSampsToSkip,
                  stYUM.iTimeSamps,
                  (iTimeSampsToSkip * dTSampInSec),
                  (stYUM.iTimeSamps * dTSampInSec));

    iTimeSampsToProc = (int) (lBytesToProc
                              / (stYUM.iNumChans * stYUM.fSampSize));
    iNumReads = (int) ceilf((float) iTimeSampsToProc / iBlockSize);
    iTotNumReads = iNumReads;

    /* optimisation - store some commonly used values in variables */
    if (0 == iWaterfallType)
    {
        iTotSampsPerBlock = stYUM.iNumChans * iBlockSize;
    }
    else
    {
        iTotSampsPerBlock = iBlockSize;
    }

    (void) printf("Processing\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n"
                  "in %d reads with block size %d time samples...\n",
                  lBytesToProc,
                  stYUM.lDataSizeTotal,
                  iTimeSampsToProc,
                  stYUM.iTimeSamps,
                  (iTimeSampsToProc * dTSampInSec),
                  (stYUM.iTimeSamps * dTSampInSec),
                  iNumReads,
                  iBlockSize);

    ///* calculate normalisation quantity for acceleration */
    //dPNorm = (dPeriod * 1e-3) / (1 + ((fAcc * stYUM.iTimeSamps * dTSampInSec)
    //                                  / (2 * YAPP_LIGHTSPEED)));

    /* calculate the threshold */
    dNumSigmas = YAPP_CalcThresholdInSigmas(iTimeSampsToProc);
    if ((double) YAPP_RET_ERROR == dNumSigmas)
    {
        (void) fprintf(stderr, "ERROR: Threshold calculation failed!\n");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    if (!((YAPP_FORMAT_DTS_TIM == iFormat)
          || (YAPP_FORMAT_DTS_DAT == iFormat)))
    {
        fStatBW = stYUM.iNumGoodChans * stYUM.fChanBW;  /* in MHz */
        (void) printf("Usable bandwidth                  : %g MHz\n", fStatBW);
        fNoiseRMS = 1.0 / sqrt(fStatBW * stYUM.dTSamp * 1e3);
        (void) printf("Expected noise RMS                : %g\n", fNoiseRMS);
    }

    if (YAPP_FORMAT_SPEC == iFormat)
    {
        /* allocate memory for the time sample goodness flag array */
        g_pcIsTimeGood = (char *) YAPP_Malloc(iTimeSampsToProc,
                                              sizeof(char),
                                              YAPP_FALSE);
        if (NULL == g_pcIsTimeGood)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for time sample goodness "
                           "flag array failed! %s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        /* set all elements to 'YAPP_TRUE' */
        (void) memset(g_pcIsTimeGood, YAPP_TRUE, iTimeSampsToProc);
    }

    /* open the data file for reading */
    g_pFData = fopen(pcFileData, "r");
    if (NULL == g_pFData)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileData,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* allocate memory for the buffer, based on the number of channels and time
       samples */
    g_pfBuf = (float *) YAPP_Malloc((size_t) stYUM.iNumChans * iBlockSize,
                                    sizeof(float),
                                    YAPP_FALSE);
    if (NULL == g_pfBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    if (1 == iNumReads)
    {
        cIsLastBlock = YAPP_TRUE;
    }

    if ((YAPP_FORMAT_FIL == iFormat) || (YAPP_FORMAT_DTS_TIM == iFormat))
    {
        /* TODO: Need to do this only if the file contains the header */
        /* skip the header */
        (void) fseek(g_pFData, (long) stYUM.iHeaderLen, SEEK_SET);
        /* skip data, if any are to be skipped */
        (void) fseek(g_pFData, lBytesToSkip, SEEK_CUR);
    }
    else
    {
        /* skip data, if any are to be skipped */
        (void) fseek(g_pFData, lBytesToSkip, SEEK_SET);
    }

    pcFilename = YAPP_GetFilenameFromPath(pcFileData);

    /* open the PGPLOT graphics device */
    if (cPlotToFile)
    {
        /* build the name of the PGPLOT device */
        (void) strcpy(acDev, pcFilename);
        (void) strcat(acDev, ".");
        (void) strcat(acDev, INFIX_FOLD);
        (void) strcat(acDev, EXT_PS);
        (void) strcat(acDev, PG_DEV_PS);
        g_iPGDev = cpgopen(acDev);
    }
    else
    {
        g_iPGDev = cpgopen(PG_DEV);
    }
    if (g_iPGDev <= 0)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening graphics device %s failed!\n",
                       PG_DEV);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* set the background colour to white and the foreground colour to
       black, if user requires so */
    if (YAPP_TRUE == iInvCols)
    {
        cpgscr(0, 1.0, 1.0, 1.0);
        cpgscr(1, 0.0, 0.0, 0.0);
    }

    /* set character height */
    cpgsch(PG_CH);

    /* the phase array */
    g_pdPhase = (double *) YAPP_Malloc(iSampsPerPeriod,
                                      sizeof(double),
                                      YAPP_FALSE);
    if (NULL == g_pdPhase)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for phase array failed! "
                       "%s!\n",
                       strerror(errno));
        cpgclos();
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    /* set up the plot's X-axis */
    g_pfPhase = (float *) YAPP_Malloc(iSampsPerPeriod,
                                      sizeof(float),
                                      YAPP_FALSE);
    if (NULL == g_pfPhase)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for phase plot array failed! "
                       "%s!\n",
                       strerror(errno));
        cpgclos();
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    for (i = 0; i < iSampsPerPeriod; ++i)
    {
        g_pdPhase[i] = (double) i * (stYUM.dTSamp / dPeriod);
        g_pfPhase[i] = (float) g_pdPhase[i];
    }
    dPhaseStep = g_pdPhase[1];

    if ((YAPP_FORMAT_DTS_TIM == iFormat)
        || (YAPP_FORMAT_DTS_DAT == iFormat))    /* time series format */
    {
        /* allocate memory for the accumulation buffer */
        if (0 == iWaterfallType)
        {
            g_pfProfBuf = (float *) YAPP_Malloc(iSampsPerPeriod,
                                               sizeof(float),
                                               YAPP_TRUE);
            if (NULL == g_pfProfBuf)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for plot buffer "
                               "failed! %s!\n",
                               strerror(errno));
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
        }
        else
        {
            /* allocate memory for the buffer, based on the number of channels and time
               samples */
            g_pf2DProfBuf = (float *) YAPP_Malloc((size_t) iSampsPerPeriod
                                                  * iNumPulses,
                                                  sizeof(float),
                                                  YAPP_TRUE);
            if (NULL == g_pf2DProfBuf)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for plot buffer "
                               "failed! %s!\n",
                               strerror(errno));
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            g_pfYAxis = (float *) YAPP_Malloc(iNumPulses,
                                              sizeof(float),
                                              YAPP_FALSE);
            if (NULL == g_pfYAxis)
            {
                (void) fprintf(stderr,
                               "ERROR: Memory allocation for Y-axis failed! %s!\n",
                               strerror(errno));
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            for (i = 0; i < iNumPulses; ++i)
            {
                g_pfYAxis[i] = (float) i;
            }
        }
    }
    else    /* filterbank format */
    {
        g_pfProfBuf = (float *) YAPP_Malloc((size_t) stYUM.iNumChans * iSampsPerPeriod,
                                            sizeof(float),
                                            YAPP_TRUE);
        if (NULL == g_pfProfBuf)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for profile buffer failed! "
                           "%s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        g_pfPlotBuf = (float *) YAPP_Malloc((size_t) stYUM.iNumChans * iSampsPerPeriod,
                                            sizeof(float),
                                            YAPP_FALSE);
        if (NULL == g_pfPlotBuf)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for plot buffer failed! "
                           "%s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        g_pfYAxis = (float *) YAPP_Malloc(stYUM.iNumChans,
                                          sizeof(float),
                                          YAPP_FALSE);
        if (NULL == g_pfYAxis)
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation for Y-axis failed! %s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        if (stYUM.cIsBandFlipped)
        {
            for (i = 0; i < stYUM.iNumChans; ++i)
            {
                g_pfYAxis[i] = stYUM.fFMax - i * stYUM.fChanBW;
            }
        }
        else
        {
            for (i = 0; i < stYUM.iNumChans; ++i)
            {
                g_pfYAxis[i] = stYUM.fFMin + i * stYUM.fChanBW;
            }
        }
    }

    /* build the name of the output profile file */
    (void) strcpy(acFileProf, pcFilename);
    (void) strcat(acFileProf, EXT_YAPP_PROFILE);

    printf("=========================== %d, %d\n", iSampsPerPeriod, iPaddingCadence);

    while (iNumReads > 0)
    {
        /* read data */
        (void) printf("\rReading data block %d.", iReadBlockCount);
        (void) fflush(stdout);
        iReadItems = YAPP_ReadData(g_pFData,
                                   g_pfBuf,
                                   stYUM.fSampSize,
                                   iTotSampsPerBlock);
        if (YAPP_RET_ERROR == iReadItems)
        {
            (void) fprintf(stderr, "ERROR: Reading data failed!\n");
            cpgclos();
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        --iNumReads;
        ++iReadBlockCount;

        if (iReadItems < iTotSampsPerBlock) /* usually, the last block */
        {
            iDiff = (stYUM.iNumChans * iBlockSize) - iReadItems;

            /* reset remaining elements to '\0' */
            (void) memset((g_pfBuf + iReadItems),
                          '\0',
                          (sizeof(float) * iDiff));
        }

        /* calculate the number of time samples in the block - this may not
           be iBlockSize for the last block, and should be iBlockSize for
           all other blocks */
        iNumSamps = iReadItems / stYUM.iNumChans;

        if (YAPP_FORMAT_SPEC == iFormat)
        {
            /* flag bad time sections, and if required, normalise within the
               beam flip time section and perform gain correction */
            for (i = 0; i < iNumSamps; ++i)
            {
                if ((dTNow >= (*stYUM.padBadTimes)[iBadTimeSect][BADTIME_BEG])
                    && (dTNow <= (*stYUM.padBadTimes)[iBadTimeSect][BADTIME_END]))
                {
                    cIsInBadTimeRange = YAPP_TRUE;
                    g_pcIsTimeGood[((iReadBlockCount-1)*iBlockSize)+i]
                        = YAPP_FALSE;
                }

                if ((YAPP_TRUE == cIsInBadTimeRange)
                    && (dTNow > (*stYUM.padBadTimes)[iBadTimeSect][BADTIME_END]))
                {
                    cIsInBadTimeRange = YAPP_FALSE;
                    ++iBadTimeSect;
                }

                /* get the beam flip time section corresponding to this
                   sample */
                if (dTNow > dTNextBF)
                {
                    dTNextBF += stYUM.dTBFInt;

                    ++iTimeSect;
                    if (iTimeSect >= stYUM.iBFTimeSects)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Beam flip time section anomaly "
                                       "detected!\n");
                        cpgclos();
                        YAPP_CleanUp();
                        return YAPP_RET_ERROR;
                    }
                }

                pfTimeSectGain = stYUM.pfBFGain + (iTimeSect * stYUM.iNumChans);
                pfSpectrum = g_pfBuf + i * stYUM.iNumChans;
                for (j = 0; j < stYUM.iNumChans; ++j)
                {
                    if (stYUM.pcIsChanGood[j])
                    {
                        pfSpectrum[j] = (pfSpectrum[j]
                                         / stYUM.pfBFTimeSectMean[iTimeSect])
                                        - pfTimeSectGain[j];
                    }
                    else    /* remove bad channels */
                    {
                        pfSpectrum[j] = 0.0;
                    }
                }

                dTNow += dTSampInSec;   /* in s */
            }
        }

        ///* update the folding period based on the acceleration */
        //dPeriod = dPNorm * 1e3 * (1 + ((fAcc * dTime) / (2 * YAPP_LIGHTSPEED)));
        //iSampsPerPeriod = (int) round(dPeriod / stYUM.dTSamp);
        //printf("%.15g, %.15g, %d\n", dPNorm, dPeriod, iSampsPerPeriod);

        if ((YAPP_FORMAT_DTS_TIM == iFormat)
            || (YAPP_FORMAT_DTS_DAT == iFormat))    /* time series format */
        {
            fMeanNoise = YAPP_CalcMean(g_pfBuf, iNumSamps, 0, 1);
            fRMSNoise = YAPP_CalcRMS(g_pfBuf, iNumSamps, 0, 1, fMeanNoise);

            /* fold data */
            if (0 == iWaterfallType)
            {
                /* TODO: need to correct for slow drift due to rounding
                         error */
                k = 0;
                double rem = dSampsPerPeriodFrac;
                double frac = 0.0;
                for (i = 0; i < iNumSamps; ++i)
                {
                    /* compute the phase */
                    dPhase = (double) lSampCount * (stYUM.dTSamp / dPeriod);
                    dPhase = dPhase - floor(dPhase);
                    /* compute the index into the profile array */
                    j = dPhase * iSampsPerPeriod;
#if 0
                    if (j == iSampsPerPeriod - 1)
                    {
                        frac += rem;
                        if (frac < 1.0)
                        {
                            j = 0;
                        }
                        else
                        {
                            frac -= floor(frac);
                            //frac = 0.0;
                        }
                    }
#endif
                    printf("%ld, %d\n", lSampCount, j);
                    g_pfProfBuf[j] += (((g_pfBuf[i] - fMeanNoise) / fRMSNoise)
                                       / DEF_FOLD_PULSES);
                    ++lSampCount;
        dTime += dTSampInSec;
                    k = (k + 1) % iSampsPerPeriod;
                }
            }
            else
            {
                k = 0;
                pfProfSpec = g_pf2DProfBuf + k * iSampsPerPeriod;
                for (i = 0; i < iNumSamps; ++i)
                {
                    /* compute the phase */
                    dPhase = (double) lSampCount * (stYUM.dTSamp / dPeriod);
                    dPhase = dPhase - floor(dPhase);
                    /* compute the index into the profile array */
                    j = dPhase * iSampsPerPeriod;
                    g_pfBuf[i] += (((g_pfBuf[i] - fMeanNoise) / fRMSNoise)
                                   / iNumPulses);
                    pfProfSpec[j] += g_pfBuf[i];
                    ++lSampCount;
                    if (lSampCount % iSampsPerPeriod == 0)
                    {
                        ++k;
                        pfProfSpec = g_pf2DProfBuf + k * iSampsPerPeriod;
                    }
        dTime += dTSampInSec;
                }
            }
        }
        else    /* filterbank format */
        {
            float afMeanNoise[stYUM.iNumChans];
            float afRMSNoise[stYUM.iNumChans];

            /* fold data */
            for (i = 0; i < iNumSamps; ++i)
            {
                /* compute the phase */
                dPhase = (double) lSampCount * (stYUM.dTSamp / dPeriod);
                dPhase = dPhase - floor(dPhase);
                /* compute the index into the profile array */
                j = dPhase * iSampsPerPeriod;
                pfSpectrum = g_pfBuf + i * stYUM.iNumChans;
                pfProfSpec = g_pfProfBuf + j * stYUM.iNumChans;
                for (k = 0; k < stYUM.iNumChans; ++k)
                {
                    /* calculate these per channel, at the first sample
                       of the block */
                    if (0 == i)
                    {
                        afMeanNoise[k] = YAPP_CalcMean(g_pfBuf,
                                                       iNumSamps,
                                                       k,
                                                       stYUM.iNumChans);
                        afRMSNoise[k] = YAPP_CalcRMS(g_pfBuf,
                                                     iNumSamps,
                                                     k,
                                                     stYUM.iNumChans,
                                                     fMeanNoise);
                    }

                    pfProfSpec[k] += (((pfSpectrum[k] - afMeanNoise[k])
                                       / afRMSNoise[k])
                                      / DEF_FOLD_PULSES);
                }
                ++lSampCount;
        dTime += dTSampInSec;
            }
        }

        if ((YAPP_FORMAT_DTS_TIM == iFormat)
            || (YAPP_FORMAT_DTS_DAT == iFormat))    /* time series format */
        {
            if (0 == iWaterfallType)
            {
                cpgeras();
                fDataMin = g_pfProfBuf[0];
                fDataMax = g_pfProfBuf[0];
                for (i = 0; i < iSampsPerPeriod; ++i)
                {
                    if (g_pfProfBuf[i] < fDataMin)
                    {
                        fDataMin = g_pfProfBuf[i];
                    }
                    if (g_pfProfBuf[i] > fDataMax)
                    {
                        fDataMax = g_pfProfBuf[i];
                    }
                }

                #ifdef DEBUG
                (void) printf("Minimum value of data             : %g\n",
                              fDataMin);
                (void) printf("Maximum value of data             : %g\n",
                              fDataMax);
                #endif

                cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
                cpgswin(g_pfPhase[0],
                        g_pfPhase[iSampsPerPeriod-1],
                        fDataMin,
                        fDataMax);
                cpglab("Phase", "Power (arbitrary units)", "Folded Profile");
                cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
                cpgsci(PG_CI_PLOT);
                cpgline(iSampsPerPeriod, g_pfPhase, g_pfProfBuf);
                cpgsci(PG_CI_DEF);
            }
            else
            {
                fDataMinOld = fDataMin;
                fDataMaxOld = fDataMax;
                fDataMin = g_pf2DProfBuf[0];
                fDataMax = g_pf2DProfBuf[0];
                for (i = 0; i < iSampsPerPeriod; ++i)
                {
                    pfProfSpec = g_pf2DProfBuf + i * iNumPulses;
                    for (j = 0; j < iNumPulses; ++j)
                    {
                        if (pfProfSpec[j] < fDataMin)
                        {
                            fDataMin = pfProfSpec[j];
                        }
                        if (pfProfSpec[j] > fDataMax)
                        {
                            fDataMax = pfProfSpec[j];
                        }
                    }
                }

                #ifdef DEBUG
                (void) printf("Minimum value of data             : %g\n",
                              fDataMin);
                (void) printf("Maximum value of data             : %g\n",
                              fDataMax);
                #endif

                if (PLOT_WATERFALL_GS == iWaterfallType)
                {
                    /* plot grayscale waterfall plot */
                    if (!cIsFirst)
                    {
                        cpgsci(0);      /* background */
                        cpgsvp(PG_WEDG_VP_ML, PG_WEDG_VP_MR, PG_WEDG_VP_MB, PG_WEDG_VP_MT);
                        cpgwedg("TI", 0.0, 3.0, fDataMinOld, fDataMaxOld, "");
                        cpgsci(PG_CI_DEF);
                    }

                    Plot2D(g_pf2DProfBuf, fDataMin, fDataMax,
                           g_pfPhase, iSampsPerPeriod, dPhaseStep,
                           g_pfYAxis, iNumPulses, 1.0,
                           "Phase", "", "",
                           iColourMap);
                }
                else
                {
                    /* plot traditional waterfall plot */
                    cpgeras();
                    cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
                    cpgswin(g_pfPhase[0],
                            g_pfPhase[iSampsPerPeriod-1],
                            fDataMin,
                            fDataMax + ((fDataMax - fDataMin) * WATERFALL_OFFSET_SCALE * iNumPulses));
                    cpglab("Phase", "", "");
                    cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
                    cpgsci(PG_CI_PLOT);
                    for (i = 0; i < iNumPulses; ++i)
                    {
                        pfProfSpec = g_pfBuf + i * iSampsPerPeriod;
                        for (j = 0; j < iSampsPerPeriod; ++j)
                        {
                            pfProfSpec[j] += (i * WATERFALL_OFFSET_SCALE * (fDataMax - fDataMin));
                        }
                        cpgline(iSampsPerPeriod, g_pfPhase, pfProfSpec);
                    }
                    cpgsci(PG_CI_DEF);
                }
            }
        }
        else    /* filterbank format */
        {
            fDataMinOld = fDataMin;
            fDataMaxOld = fDataMax;
            fDataMin = g_pfProfBuf[0];
            fDataMax = g_pfProfBuf[0];
            for (i = 0; i < iSampsPerPeriod; ++i)
            {
                pfProfSpec = g_pfProfBuf + i * stYUM.iNumChans;
                for (j = 0; j < stYUM.iNumChans; ++j)
                {
                    if (pfProfSpec[j] < fDataMin)
                    {
                        fDataMin = pfProfSpec[j];
                    }
                    if (pfProfSpec[j] > fDataMax)
                    {
                        fDataMax = pfProfSpec[j];
                    }
                }
            }

            #ifdef DEBUG
            (void) printf("Minimum value of data             : %g\n",
                          fDataMin);
            (void) printf("Maximum value of data             : %g\n",
                          fDataMax);
            #endif

            /* get the transpose of the two-dimensional array */
            k = 0;
            l = 0;
            m = 0;
            for (i = 0; i < iSampsPerPeriod; ++i)
            {
                pfProfSpec = g_pfProfBuf + i * stYUM.iNumChans;
                for (j = 0; j < stYUM.iNumChans; ++j)
                {
                    l = m + k * iSampsPerPeriod;
                    g_pfPlotBuf[l] = pfProfSpec[j];
                    ++k;
                }
                k = 0;
                ++m;
            }

            if (!cIsFirst)
            {
                cpgsci(0);      /* background */
                cpgsvp(PG_WEDG_VP_ML, PG_WEDG_VP_MR, PG_WEDG_VP_MB, PG_WEDG_VP_MT);
                cpgwedg("TI", 0.0, 3.0, fDataMinOld, fDataMaxOld, "");
                cpgsci(PG_CI_DEF);
            }
            Plot2D(g_pfPlotBuf, fDataMin, fDataMax,
                   g_pfPhase, iSampsPerPeriod, dPhaseStep,
                   g_pfYAxis, stYUM.iNumChans, stYUM.fChanBW,
                   "Phase", "Frequency (MHz)", "Folded Dynamic Spectrum",
                   iColourMap);
        }

        if (!cPlotToFile)
        {
            /* display the plot number */
            (void) sprintf(acLabel, "%d / %d", iReadBlockCount, iTotNumReads);
            cpgmtxt("T", -1.5, 0.99, 1.0, acLabel);
        }

        if (!(cIsLastBlock))
        {
            if (!(cIsNonInteractive))
            {
                /* draw the 'next' and 'exit' buttons */
                cpgsvp(PG_VP_BUT_ML, PG_VP_BUT_MR, PG_VP_BUT_MB, PG_VP_BUT_MT);
                cpgswin(PG_BUT_L, PG_BUT_R, PG_BUT_B, PG_BUT_T);
                cpgsci(PG_BUT_FILLCOL); /* set the fill colour */
                cpgrect(PG_BUTNEXT_L, PG_BUTNEXT_R, PG_BUTNEXT_B, PG_BUTNEXT_T);
                cpgrect(PG_BUTEXIT_L, PG_BUTEXIT_R, PG_BUTEXIT_B, PG_BUTEXIT_T);
                cpgsci(0);  /* set colour index to background */
                cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");

                fButX = (PG_BUTNEXT_R - PG_BUTNEXT_L) / 2;
                fButY = (PG_BUTNEXT_T - PG_BUTNEXT_B) / 2;

                while (YAPP_TRUE)
                {
                    iRet = cpgcurs(&fButX, &fButY, &cCurChar);
                    if (0 == iRet)
                    {
                        (void) fprintf(stderr,
                                       "WARNING: "
                                       "Reading cursor parameters failed!\n");
                        break;
                    }

                    if (((fButX >= PG_BUTNEXT_L) && (fButX <= PG_BUTNEXT_R))
                        && ((fButY >= PG_BUTNEXT_B) && (fButY <= PG_BUTNEXT_T)))
                    {
                        /* animate button click */
                        cpgsci(PG_BUT_FILLCOL);
                        cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUTNEXT_CL_TEXT_L, PG_BUTNEXT_CL_TEXT_B, "Next");
                        (void) usleep(PG_BUT_CL_SLEEP);
                        cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                   colour */
                        cpgtext(PG_BUTNEXT_CL_TEXT_L, PG_BUTNEXT_CL_TEXT_B, "Next");
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUTNEXT_TEXT_L, PG_BUTNEXT_TEXT_B, "Next");
                        cpgsci(PG_CI_DEF);  /* reset colour index to black */
                        (void) usleep(PG_BUT_CL_SLEEP);

                        break;
                    }
                    else if (((fButX >= PG_BUTEXIT_L) && (fButX <= PG_BUTEXIT_R))
                        && ((fButY >= PG_BUTEXIT_B) && (fButY <= PG_BUTEXIT_T)))
                    {
                        /* animate button click */
                        cpgsci(PG_BUT_FILLCOL);
                        cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUTEXIT_CL_TEXT_L, PG_BUTEXIT_CL_TEXT_B, "Exit");
                        (void) usleep(PG_BUT_CL_SLEEP);
                        cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                   colour */
                        cpgtext(PG_BUTEXIT_CL_TEXT_L, PG_BUTEXIT_CL_TEXT_B, "Exit");
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUTEXIT_TEXT_L, PG_BUTEXIT_TEXT_B, "Exit");
                        cpgsci(PG_CI_DEF);  /* reset colour index to black */
                        (void) usleep(PG_BUT_CL_SLEEP);

                        cpgclos();
                        YAPP_CleanUp();
                        return YAPP_RET_SUCCESS;
                    }
                }
            }
            else
            {
                /* pause before erasing */
                (void) usleep(PG_PLOT_SLEEP);
            }
        }

        if (1 == iNumReads)
        {
            cIsLastBlock = YAPP_TRUE;
        }
        cIsFirst = YAPP_FALSE;
    }

    /* write profile to file */
    /* NOTE: no support for filterbank format data */
    if ((YAPP_FORMAT_DTS_TIM == iFormat)
        || (YAPP_FORMAT_DTS_DAT == iFormat))    /* time series format */
    {
        /* NOTE: no support for waterfall data */
        if (0 == iWaterfallType)
        {
            /* open the output profile file */
            pFProfile = fopen(acFileProf, "w");
            if (NULL == pFProfile)
            {
                fprintf(stderr,
                        "ERROR: Opening file %s failed! %s.\n",
                        acFileProf,
                        strerror(errno));
                cpgclos();
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }

            /* write necessary metadata */
            (void) fprintf(pFProfile,
                           "# Centre frequency                  : %.10g MHz\n",
                            stYUM.fFCentre);
            (void) fprintf(pFProfile,
                           "# Original channel bandwidth        : %.10g MHz\n",
                            stYUM.fChanBW);
            (void) fprintf(pFProfile,
                           "# Bandwidth                         : %.10g MHz\n",
                           stYUM.fBW);
            (void) fprintf(pFProfile,
                           "# Duration of data                  : %g s\n",
                           (stYUM.iTimeSamps * (stYUM.dTSamp / 1e3)));
            /* write profile bins */
            for (i = 0; i < iSampsPerPeriod; ++i)
            {
                (void) fprintf(pFProfile, "%.10g\n", g_pfProfBuf[i]);
            }

            (void) fclose(pFProfile);
        }
    }

    (void) printf("DONE!\n");

    cpgclos();
    YAPP_CleanUp();

    return YAPP_RET_SUCCESS;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <data-file>\n",
                  pcProgName);
    (void) printf("    -h  --help                          ");
    (void) printf("Display this usage information\n");
    (void) printf("    -s  --skip <time>                   ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                        ");
    (void) printf("skipped\n");
    (void) printf("                                        ");
    (void) printf("(default is 0 s)\n");
    (void) printf("    -p  --proc <time>                   ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                        ");
    (void) printf("processed\n");
    (void) printf("                                        ");
    (void) printf("(default is all)\n");
    (void) printf("    -t  --period <period>               ");
    (void) printf("Folding period in milliseconds\n");
    (void) printf("    -w  --waterfall <numpulses>         ");
    (void) printf("Show a waterfall plot (pulse number\n");
    (void) printf("                                        ");
    (void) printf("versus phase) instead of a folded\n");
    (void) printf("                                        ");
    (void) printf("profile\n");
    (void) printf("    -x  --waterfallgs <numpulses>       ");
    (void) printf("Show a grascale waterfall plot (pulse\n");
    (void) printf("                                        ");
    (void) printf("number versus phase) instead of a\n");
    (void) printf("                                        ");
    (void) printf("folded profile\n");
    (void) printf("    -m  --colour-map <name>             ");
    (void) printf("Colour map for plotting\n");
    (void) printf("                                        ");
    (void) printf("(default is 'jet')\n");
    (void) printf("    -f  --file                          ");
    (void) printf("Plot to file, instead of to screen\n");
    (void) printf("    -i  --invert                        ");
    (void) printf("Invert background and foreground\n");
    (void) printf("                                        ");
    (void) printf("colours in plots\n");
    (void) printf("    -e  --non-interactive               ");
    (void) printf("Run in non-interactive mode\n");
    (void) printf("    -v  --version                       ");
    (void) printf("Display the version\n");

    return;
}

