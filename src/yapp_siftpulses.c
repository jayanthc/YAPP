/*
 * @file yapp_siftpulses.c
 * Program to generate a single-pulse diagnostic plot from given dedispersed
 *  time series data.
 *
 * @verbatim
 * Usage: yapp_siftpulses [options] <data-file-dm0> ... <data-file-dmN-1>
 *     -h  --help                           Display this usage information
 *     -n  --nsamp <samples>                Number of samples read in one block
 *                                          (default is 4096 samples)
 *     -t  --threshold <sigmas>             Threshold in sigmas.
 *     -i  --invert                         Invert the background and foreground
 *                                          colours in plots
 *     -e  --non-interactive                Run in non-interactive mode
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2013.05.06
 */

#include "yapp.h"
#include "yapp_sigproc.h"   /* for SIGPROC filterbank file format support */

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* PGPLOT device ID */
extern int g_iPGDev;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
float **g_ppfBuf = NULL;
float *g_pfOutBuf = NULL;
float *g_pfXAxis = NULL;

int main(int argc, char *argv[])
{
    FILE **ppFIn = NULL;
    int iNumDMs = 0;
    int iFormat = DEF_FORMAT;
    YUM_t stYUM = {{0}};
    float *pfDM = NULL;
    int iBlockSize = DEF_SIZE_BLOCK;
    int iTotSampsPerBlock = 0;  /* iBlockSize */
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    int iNumReads = 0;
    int iTotNumReads = 0;
    int iReadBlockCount = 0;
    char cIsLastBlock = YAPP_FALSE;
    int iRet = YAPP_RET_SUCCESS;
    int iReadItems = 0;
    int iNumSamps = 0;
    int iDiff = 0;
    int iNumRandEvents = 0;
    int iNumEvents = 0;
    float fMedian = 0.0;
    float fRMS = 0.0;
    float fThreshold = 0.0;
    double dTNow = 0.0;
    float fTemp = 0.0;
    FILE *pFTemp = NULL;
    char cIsFirst = YAPP_TRUE;
    int i = 0;
    int j = 0;
    int iInvCols = YAPP_FALSE;
    char cIsNonInteractive = YAPP_FALSE;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hn:t:iev";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "nsamp",                  1, NULL, 'n' },
        { "threshold",              1, NULL, 't' },
        { "invert",                 0, NULL, 'i' },
        { "non-interactive",        0, NULL, 'e' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 'n':   /* -n or --nsamp */
                /* set option */
                iBlockSize = atoi(optarg);
                /* validate - PGPLOT does not like iBlockSize = 1 */
                if (iBlockSize < 2)
                {
                    (void) fprintf(stderr,
                                   "ERROR: Number of samples must be > 1!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 't':  /* -t or --threshold */
                fThreshold = atof(optarg);
                break;

            case 'i':  /* -i or --invert */
                /* set option */
                iInvCols = YAPP_TRUE;
                break;

            case 'e':  /* -e or --non-interactive */
                /* set option */
                cIsNonInteractive = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* only one file - no need to add */
    iNumDMs = argc - optind;
    if (iNumDMs == 1)
    {
        (void) fprintf(stderr, "ERROR: Only one input file given!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* user input validation - check the file type for all input files */
    for (i = optind; i < argc; ++i)
    {
        /* determine the file type */
        iFormat = YAPP_GetFileType(argv[i]);
        if (YAPP_RET_ERROR == iFormat)
        {
            (void) fprintf(stderr,
                           "ERROR: File type determination failed!\n");
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        if ((iFormat != YAPP_FORMAT_DTS_TIM)
            && (iFormat != YAPP_FORMAT_DTS_DAT))
        {
            (void) fprintf(stderr,
                           "ERROR: Invalid file type!\n");
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
    }

    /* read metadata */
    /* NOTE: it is assumed that all files correspond to a single observation,
             and that sampling time is the same for all files. the only
             information taken from all files except the last one is the DM.
             general metadata is read from the last file */
    /* allocate memory for the DM array */
    pfDM = (float *) YAPP_Malloc((size_t) iNumDMs,
                                 sizeof(float),
                                 YAPP_FALSE);
    if (NULL == pfDM)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    for (i = optind; i < argc; ++i)
    {
        (void) memset(&stYUM, '\0', sizeof(YUM_t));
        iRet = YAPP_ReadMetadata(argv[i], iFormat, &stYUM);
        if (iRet != YAPP_RET_SUCCESS)
        {
            (void) fprintf(stderr,
                           "ERROR: Reading metadata failed for file %s!\n",
                           argv[i]);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        pfDM[i-optind] = (float) stYUM.dDM;
    }

    /* convert sampling interval to seconds */
    dTSampInSec = stYUM.dTSamp / 1e3;

    iNumReads = (int) ceilf(((float) stYUM.iTimeSamps) / iBlockSize);
    iTotNumReads = iNumReads;

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = iBlockSize;

    /* open the time series data files for reading */
    /* allocate memory for the file pointer array */
    ppFIn = (FILE **) YAPP_Malloc((size_t) iNumDMs,
                                  sizeof(FILE *),
                                  YAPP_FALSE);
    if (NULL == ppFIn)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    for (i = optind; i < argc; ++i)
    {
        ppFIn[i-optind] = fopen(argv[i], "r");
        if (NULL == ppFIn[i-optind])
        {
            (void) fprintf(stderr,
                           "ERROR: Opening file %s failed! %s.\n",
                           argv[i],
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }

        if (YAPP_FORMAT_DTS_TIM == iFormat)
        {
            /* skip the header */
            (void) fseek(ppFIn[i-optind], (long) stYUM.iHeaderLen, SEEK_SET);
        }
    }

    /* sort the input files and DM array in descending DM order */
    for (i = 0; i < iNumDMs; ++i)
    {
        for (j = i; j < iNumDMs; ++j)
        {
            if (pfDM[j] > pfDM[i])
            {
                /* swap DMs */
                fTemp = pfDM[i];
                pfDM[i] = pfDM[j];
                pfDM[j] = fTemp;

                /* swap file handles */
                pFTemp = ppFIn[i];
                ppFIn[i] = ppFIn[j];
                ppFIn[j] = pFTemp;
            }
        }
    }

    /* allocate memory for the buffer pointer array */
    g_ppfBuf = (float **) YAPP_Malloc((size_t) iNumDMs,
                                      sizeof(float *),
                                      YAPP_FALSE);
    if (NULL == g_ppfBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    /* allocate memory for the buffer */
    for (i = 0; i < iNumDMs; ++i)
    {
        g_ppfBuf[i] = (float *) YAPP_Malloc((size_t) iBlockSize,
                                            sizeof(float),
                                            YAPP_FALSE);
        if (NULL == g_ppfBuf[i])
        {
            (void) fprintf(stderr,
                           "ERROR: Memory allocation failed! %s!\n",
                           strerror(errno));
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
    }

    /* allocate memory for single pulses */
    /* compute number of events due to noise alone */
    iNumRandEvents = iNumDMs * stYUM.iTimeSamps * sqrt(M_PI)
                     * erfc(fThreshold);

    if (1 == iNumReads)
    {
        cIsLastBlock = YAPP_TRUE;
    }

    /* open the PGPLOT graphics device */
    g_iPGDev = cpgopen(PG_DEV);
    if (g_iPGDev <= 0)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening graphics device %s failed!\n",
                       PG_DEV);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* set the background colour to white and the foreground colour to
       black, if user requires so */
    if (YAPP_TRUE == iInvCols)
    {
        cpgscr(0, 1.0, 1.0, 1.0);
        cpgscr(1, 0.0, 0.0, 0.0);
    }

    cpgsch(PG_CH);

    /* set up the plot's X-axis */
    g_pfXAxis = (float *) YAPP_Malloc(stYUM.iTimeSamps,
                                      sizeof(float),
                                      YAPP_FALSE);
    if (NULL == g_pfXAxis)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for X-axis failed! %s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    for (i = 0; i < stYUM.iTimeSamps; ++i)
    {
        g_pfXAxis[i] = i * dTSampInSec;
    }

    /* allocate memory for the accumulation buffer */
    g_pfOutBuf = (float *) YAPP_Malloc((size_t) iBlockSize,
                                       sizeof(float),
                                       YAPP_TRUE);
    if (NULL == g_pfOutBuf)
    {
        (void) fprintf(stderr,
                       "ERROR: Memory allocation for plot buffer failed! "
                       "%s!\n",
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* set up plot */
    cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
    cpgswin(g_pfXAxis[0],
            g_pfXAxis[stYUM.iTimeSamps-1],
            pfDM[iNumDMs-1],
            pfDM[0]);
    cpglab("Time (s)", "DM (pc cm\\u-3\\d)", "");
    cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
    cpgsci(PG_CI_PLOT);

    while (iNumReads > 0)
    {
        /* read data */
        (void) printf("\rReading data block %d of %d.",
                      iReadBlockCount + 1,
                      iTotNumReads);
        (void) fflush(stdout);
        for (i = 0; i < iNumDMs; ++i)
        {
            iReadItems = YAPP_ReadData(ppFIn[i],
                                       g_ppfBuf[i],
                                       stYUM.fSampSize,
                                       iTotSampsPerBlock);
            if (YAPP_RET_ERROR == iReadItems)
            {
                (void) fprintf(stderr, "ERROR: Reading data failed!\n");
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }

            if (iReadItems < iTotSampsPerBlock)
            {
                iDiff = iBlockSize - iReadItems;

                /* reset remaining elements to '\0' */
                (void) memset((g_ppfBuf[0] + iReadItems),
                              '\0',
                              (sizeof(float) * iDiff));
            }

            /* calculate the number of time samples in the block - this may not
               be iBlockSize for the last block, and should be iBlockSize for
               all other blocks */
            iNumSamps = iReadItems;
        }
        --iNumReads;
        ++iReadBlockCount;

        /* calculate the reference median and standard deviation */
        if (cIsFirst)
        {
            for (i = 0; i < iNumDMs; ++i)
            {
                /* TODO: compute the median instead of the mean */
                fMedian = YAPP_CalcMean(g_ppfBuf[i], iNumSamps, 0, 1);
                fRMS = YAPP_CalcRMS(g_ppfBuf[i], iNumSamps, 0, 1, fMedian);
            }
            (void) printf("Mean: %g\n", fMedian);
            (void) printf("Standard deviation: %g\n", fRMS);
            cIsFirst = YAPP_FALSE;
        }

        /* search for strong pulses */
        for (i = 0; i < iNumSamps; ++i)
        {
            for (j = 0; j < iNumDMs; ++j)
            {
                float fSNR = (g_ppfBuf[j][i] - fMedian) / fRMS;
                if (fSNR > fThreshold)
                {
                    float fLW = powf(3, fSNR - fThreshold);
                    if (fLW < 1.0)
                    {
                        cpgsci(1);
                        fLW = 1.0;
                    }
                    else if (fLW > 201.0)
                    {
                        cpgsci(2);
                        fLW = 201.0;
                    }
                    else
                    {
                        cpgsci(PG_CI_PLOT);
                    }
                    cpgslw(fLW);
                    cpgpt1((float) dTNow, pfDM[j], -1);
                    ++iNumEvents;
                }
            }
            dTNow += dTSampInSec;
        }

        if (1 == iNumReads)
        {
            cIsLastBlock = YAPP_TRUE;
        }
    }

    (void) printf("%d events of an expected %d detected.\n",
                  iNumEvents,
                  iNumRandEvents);

    (void) printf("DONE!\n");

    YAPP_CleanUp();

    return YAPP_RET_SUCCESS;
}


/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <data-file-dm0> ... "
                  "<data-file-dmN-1>\n",
                  pcProgName);
    (void) printf("    -h  --help                          ");
    (void) printf("Display this usage information\n");
    (void) printf("    -n  --nsamp <samples>               ");
    (void) printf("Number of samples read in one block\n");
    (void) printf("                                        ");
    (void) printf("(default is 4096 samples)\n");
    (void) printf("    -t  --threshold                     ");
    (void) printf("Threshold in sigmas\n");
    (void) printf("    -i  --invert                        ");
    (void) printf("Invert background and foreground\n");
    (void) printf("                                        ");
    (void) printf("colours in plots\n");
    (void) printf("    -e  --non-interactive               ");
    (void) printf("Run in non-interactive mode\n");
    (void) printf("    -v  --version                       ");
    (void) printf("Display the version\n");

    return;
}

