/*
 * @file yapp_viewdata.c
 * Program to plot raw dynamic spectrum data.
 *
 * @verbatim
 * Usage: yapp_viewdata [options] <dynamic-spectrum-data-file>
 *     -h  --help                           Display this usage information
 *     -s  --data-skip-percent <percentage> The percentage of data to be skipped
 *     -S  --data-skip-time <time>          The length of data in seconds, to be
 *                                          skipped
 *     -p  --data-proc-percent <percentage> The percentage of data to be
 *                                          processed
 *                                          (default is 100)
 *     -P  --data-proc-time <time>          The length of data in seconds, to be
 *                                          processed
 *                                          (default is all)
 *     -b  --block-size <samples>           Number of samples read in one block
 *                                          (default is 4096 samples)
 *     -c  --clip-level <level>             Number of sigmas above threshold;
 *                                          will clip anything above this level
 *     -i  --invert                         Invert the background and foreground
 *                                          colours in plots
 *     -n  --non-interactive                Run in non-interactive mode
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2008.11.14
 */

/* TODO: 1. ORT & MST radar data reads nan or inf for the last few samples of
            data
         2. No need for DEF_PROC_TIME
         3. Read and plot dedispersed data */

#include "yapp.h"
#include "yapp_sigproc.h"   /* for SIGPROC filterbank file format support */

/* TODO: Handle the headerless/header-separated filterbank format file */

/* DEV:
int SetColourMap(int iIsMonochrome,
                 int iIsColInv,
                 float fColMin,
                 float fColMax); */

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
double *g_pdDelayTab = NULL;
char *g_pcIsChanGood = NULL;
char *g_pcIsTimeGood = NULL;
float *g_pfBFTimeSectMean = NULL;
float *g_pfBFGain = NULL;
double (*g_padBadTimes)[][NUM_BAD_BOUNDS] = NULL;
float *g_pfBuf = NULL;
float *g_pfPlotBuf = NULL;
float *g_pfXAxis = NULL;
float *g_pfFreq = NULL;

int main(int argc, char *argv[])
{
    FILE *pFSpec = NULL;
    FILE *pFCfg = NULL;
    char *pcFileSpec = NULL;
    char acFileCfg[LEN_GENSTRING] = {0};
    int iFormat = DEF_FORMAT;
    int iDataSkipPercent = DEF_SKIP_PERCENT;
    int iDataSkipTime = DEF_SKIP_TIME;
    int iDataProcPercent = DEF_PROC_PERCENT;
    int iDataProcTime = DEF_PROC_TIME;
    int iProcSpec = PROC_SPEC_NOTSEL;   /* by default, the processing
                                           specification is not selected */
    int iChanGoodness = (int) YAPP_TRUE;
    float fFMin = 0.0;
    float fFMax = 0.0;
    float fChanBW = 0.0;
    int iNumChans = 0;
    float fSampSize = 0.0;      /* number of bits that make a sample */
    int iTotSampsPerBlock = 0;  /* iNumChans * iBlockSize */
    int iDataSizePerBlock = 0;  /* fSampSize * iNumChans * iBlockSize */
    int iNumGoodChans = 0;
    char cIsBandFlipped = YAPP_FALSE;
    float fStatBW = 0.0;
    float fNoiseRMS = 0.0;
    float fThreshold = 0.0;
    float fSNRMin = 0.0;
    float fClipLevel = 0.0;
    double dNumSigmas = 0.0;
    double dTSamp = 0.0;        /* holds sampling time in ms */
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    YAPP_SIGPROC_HEADER stHeader = {{0}};
    char acLabel[LEN_GENSTRING] = {0};
    int iHeaderLen = 0;
    int iFlagSplicedData = YAPP_FALSE;
    int iNumBands = 0;
    int iNumTicksY = PG_TICK_STEPS_Y;
    float afTicks[YAPP_MAX_NUM_BANDS] = {0};
    int iLen = 0;
    double dFChan = 0.0;
    float fFCh1 = 0.0;          /* frequency of the first channel */
    int iBytesPerFrame = 0;
    float fFCentre = 0.0;
    float fBW = 0.0;
    int iChanBeg = 0;
    int iChanEnd = 0;
    char acPulsar[LEN_GENSTRING] = {0};
    int iDay = 0;
    int iMonth = 0;
    int iYear = 0;
    int iHour = 0;
    int iMin = 0;
    float fSec = 0.0;
    char acSite[LEN_GENSTRING] = {0};
    double dTNextBF = 0.0;
    double dTBFInt = 0.0;
    int iBFTimeSects = 0;
    float *pfTimeSectGain = NULL;
    int iNumBadTimes = 0;
    double dTNow = 0.0;
    int iTimeSect = 0;
    int iBadTimeSect = 0;
    char cIsInBadTimeRange = YAPP_FALSE;
    float *pfSpectrum = NULL;
    long lBytesToSkip = 0;
    long lBytesToProc = 0;
    int iTimeSamps = 0;
    int iTimeSampsSkip = 0;
    int iTimeSampsToProc = 0;
    int iBlockSize = DEF_SIZE_BLOCK;
    int iNumReads = 0;
    int iTotNumReads = 0;
    int iReadBlockCount = 0;
    int iSecBufReadSampCount = 0;   /* iReadBlockCount * iBlockSize */
    char cIsLastBlock = YAPP_FALSE;
    struct stat stFileStats = {0};
    long lDataSizeTotal = 0;
    int iRet = YAPP_RET_SUCCESS;
    int iFlagBW = 0;
    float afTM[6] = {0.0};
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    int iReadItems = 0;
    float fColMin = 0.0;
    float fColMax = 0.0;
    float fXStep = 0.0;
    float fYStep = 0.0;
    float fButX = 0.0;
    float fButY = 0.0;
    char cCurChar = 0;
    int iNumSamps = 0;
    int iDiff = 0;
    int i = 0;
    int j = 0;
    int k = 0;
    int l = 0;
    int m = 0;
    int iInvCols = YAPP_FALSE;
    char cIsNonInteractive = YAPP_FALSE;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hs:S:p:P:b:c:inv";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "data-skip-percent",      1, NULL, 's' },
        { "data-skip-time",         1, NULL, 'S' },
        { "data-proc-percent",      1, NULL, 'p' },
        { "data-proc-time",         1, NULL, 'P' },
        { "block-size",             1, NULL, 'b' },
        { "clip-level",             1, NULL, 'c' },
        { "invert",                 0, NULL, 'i' },
        { "non-interactive",        0, NULL, 'n' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 's':   /* -s or --data-skip-percent */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_PERCENT == iProcSpec))
                {
                    iDataSkipPercent = atoi(optarg);
                    if (iDataSkipPercent > 100)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Data skip percentage should be "
                                       "less than 100!\n");
                        PrintUsage(pcProgName);
                        return YAPP_RET_ERROR;
                    }

                    iProcSpec = PROC_SPEC_PERCENT;
                }
                else    /* if the specification mode is time, not percentage */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'S':   /* -S or --data-skip-time */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_TIME == iProcSpec))
                {
                    iDataSkipTime = atoi(optarg);
                    iProcSpec = PROC_SPEC_TIME;
                }
                else    /* if the specification mode is percentage, not time */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'p':   /* -p or --data-proc-percent */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_PERCENT == iProcSpec))
                {
                    iDataProcPercent = atoi(optarg);
                    if (iDataProcPercent > 100)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Data processing percentage "
                                       "should be less than 100!\n");
                        PrintUsage(pcProgName);
                        return YAPP_RET_ERROR;
                    }

                    iProcSpec = PROC_SPEC_PERCENT;
                }
                else    /* if the specification mode is time, not percentage */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'P':   /* -P or --data-proc-time */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_TIME == iProcSpec))
                {
                    iDataProcTime = atoi(optarg);
                    iProcSpec = PROC_SPEC_TIME;
                }
                else    /* if the specification mode is percentage, not time */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'b':   /* -b or --block-size */
                /* set option */
                iBlockSize = atoi(optarg);
                break;

            case 'c':   /* -c or --clip-level */
                /* set option */
                fClipLevel = (float) atof(optarg);
                break;

            case 'i':  /* -i or --invert */
                /* set option */
                iInvCols = YAPP_TRUE;
                break;

            case 'n':  /* -n or --non-interactive */
                /* set option */
                cIsNonInteractive = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileSpec = argv[optind];

    /* determine the file type */
    iFormat = YAPP_GetFileType(pcFileSpec);
    if (YAPP_RET_ERROR == iFormat)
    {
        (void) fprintf(stderr,
                       "ERROR: File type determination failed!\n");
        return YAPP_RET_ERROR;
    }
    else if (YAPP_FORMAT_SPEC == iFormat) /* 'spec' format */
    {
        /* NOTE: reading data in Desh's 'spec' file format + associated
           'spec_cfg' file format */
        fSampSize = (float) sizeof(float);  /* spec files are 32-bit floats */

        /* build the 'cfg' file name from the 'spec' file name, and open it */
        (void) strcpy(acFileCfg, pcFileSpec);
        (void) strcat(acFileCfg, SUFFIX_CFG);
        pFCfg = fopen(acFileCfg, "r");
        if (NULL == pFCfg)
        {
            (void) fprintf(stderr,
                           "ERROR: Opening file %s failed! %s.\n",
                           acFileCfg,
                           strerror(errno));
            return YAPP_RET_ERROR;
        }

        /* read the first few parameters from the 'cfg' file */
        (void) fscanf(pFCfg,
                      " %lf %d %f %f %d %d %s %d %d %d %d %d %f %s %lf %lf",
                      &dTSamp,          /* in ms */
                      &iBytesPerFrame,  /* iNumChans * fSampSize */
                      &fFCentre,        /* in MHz */
                      &fBW,             /* in kHz */
                      &iChanBeg,
                      &iChanEnd,
                      acPulsar,
                      &iDay,
                      &iMonth,
                      &iYear,
                      &iHour,
                      &iMin,
                      &fSec,
                      acSite,
                      &dTNextBF,        /* in s */
                      &dTBFInt);        /* in s */

        /* handle negative bandwidths */
        if (fBW < 0)
        {
            fBW = -fBW;
            cIsBandFlipped = YAPP_TRUE;  /* NOTE: not used, as of now */
        }

        /* convert the bandwidth to MHz */
        fBW /= 1000.0;

        /* store a copy of the sampling interval in s */
        dTSampInSec = dTSamp / 1000.0;

        (void) printf("Field name                        : %s\n", acPulsar);
        (void) printf("Observing site                    : %s\n", acSite);
        (void) printf("Date of observation               : %d.%d.%d\n",
                      iYear,
                      iMonth,
                      iDay);
        (void) printf("Time of observation               : %d:%d:%g\n",
                      iHour,
                      iMin,
                      fSec);
        (void) printf("Bytes per frame                   : %d\n",
                      iBytesPerFrame);
        (void) printf("Centre frequency                  : %g MHz\n", fFCentre);
        (void) printf("Bandwidth                         : %g MHz\n", fBW);
        if (cIsBandFlipped)
        {
            (void) printf("                                    Band flip.\n");
        }
        else
        {
            (void) printf("                                    "
                          "No band flip.\n");
        }
        (void) printf("Sampling interval                 : %.10g ms\n", dTSamp);
        (void) printf("First channel index               : %d\n", iChanBeg);
        (void) printf("Last channel index                : %d\n", iChanEnd);

        /* calculate the number of channels */
        iNumChans = iChanEnd - iChanBeg + 1;
        (void) printf("Number of channels                : %d\n", iNumChans);

        /* calculate the channel bandwidth */
        fChanBW = fBW / iNumChans;  /* in MHz */
        (void) printf("Channel bandwidth                 : %.10g MHz\n",
                      fChanBW);

        /* calculate the absolute min and max frequencies */
        fFMin = fFCentre - (fBW / 2) + (fChanBW / 2);
        (void) printf("Lowest frequency                  : %.10g MHz\n", fFMin);
        fFMax = fFCentre + (fBW / 2) - (fChanBW / 2);
        (void) printf("Highest frequency                 : %.10g MHz\n", fFMax);

        g_pcIsChanGood = (char *) malloc(sizeof(char) * iNumChans);
        if (NULL == g_pcIsChanGood)
        {
            perror("malloc - g_pcIsChanGood");
            (void) fclose(pFCfg);
            return YAPP_RET_ERROR;
        }

        /* read the channel goodness flags */
        for (i = 0; i < iNumChans; ++i)
        {
            (void) fscanf(pFCfg, " %d", &iChanGoodness);
            g_pcIsChanGood[i] = (char) iChanGoodness;
            if (g_pcIsChanGood[i])
            {
                ++iNumGoodChans;
            }
        }
        (void) printf("Number of good channels           : %d\n",
                      iNumGoodChans);

        (void) printf("First band flip time              : %.10g s\n",
                      dTNextBF);
        (void) printf("Band flip interval                : %.10g s\n", dTBFInt);

        (void) fscanf(pFCfg, " %d", &iBFTimeSects);

        (void) printf("Number of band flip time sections : %d\n", iBFTimeSects);

        g_pfBFTimeSectMean = (float *) malloc(sizeof(float) * iBFTimeSects);
        if (NULL == g_pfBFTimeSectMean)
        {
            perror("malloc - g_pfBFTimeSectMean");
            (void) fclose(pFCfg);
            CleanUp();
            return YAPP_RET_ERROR;
        }

        for (i = 0; i < iBFTimeSects; ++i)
        {
            (void) fscanf(pFCfg, " %f", &g_pfBFTimeSectMean[i]);
        }

        g_pfBFGain = (float *) malloc(sizeof(float) * iNumChans * iBFTimeSects);
        if (NULL == g_pfBFGain)
        {
            perror("malloc - g_pfBFGain");
            (void) fclose(pFCfg);
            CleanUp();
            return YAPP_RET_ERROR;
        }

        for (i = 0; i < (iNumChans * iBFTimeSects); ++i)
        {
            (void) fscanf(pFCfg, " %f", &g_pfBFGain[i]);
        }
        pfTimeSectGain = g_pfBFGain;

        (void) fscanf(pFCfg, " %d", &iNumBadTimes);
        (void) printf("Number of bad time sections       : %d\n", iNumBadTimes);
        g_padBadTimes = (double(*) [][NUM_BAD_BOUNDS]) malloc(sizeof(double)
                                                              * iNumBadTimes
                                                              * NUM_BAD_BOUNDS);
        if (NULL == g_padBadTimes)
        {
            perror("malloc - g_padBadTimes");
            (void) fclose(pFCfg);
            CleanUp();
            return YAPP_RET_ERROR;
        }
        for (i = 0; i < iNumBadTimes; ++i)
        {
            for (j = 0; j < NUM_BAD_BOUNDS; ++j)
            {
                (void) fscanf(pFCfg, " %lf", &((*g_padBadTimes)[i][j]));
            }
        }

        (void) fclose(pFCfg);

        iRet = stat(pcFileSpec, &stFileStats);
        if (iRet != YAPP_RET_SUCCESS)
        {
            (void) fprintf(stderr,
                           "ERROR: Failed to stat %s: %s!\n",
                           pcFileSpec,
                           strerror(errno));
            CleanUp();
            return YAPP_RET_ERROR;
        }
        lDataSizeTotal = (long) stFileStats.st_size;
        (void) printf("Duration of data in\n");
        (void) printf("    Bytes                         : %ld\n",
                      (lDataSizeTotal / iNumChans));
        iTimeSamps = (int) (lDataSizeTotal / (iNumChans * fSampSize));
        (void) printf("    Time samples                  : %d\n", iTimeSamps);
        (void) printf("    Time                          : %g s\n",
                      (iTimeSamps * dTSampInSec));
    }
    else    /* 'fil' format */
    {
        /* open the dynamic spectrum data file for reading */
        pFSpec = fopen(pcFileSpec, "r");
        if (NULL == pFSpec)
        {
            (void) fprintf(stderr,
                           "ERROR: Opening file %s failed! %s.\n",
                           pcFileSpec,
                           strerror(errno));
            CleanUp();
            return YAPP_RET_ERROR;
        }

        /* read the parameters from the header section of the file */
        /* start with the 'HEADER_START' label */
        (void) fread(&iLen, sizeof(iLen), 1, pFSpec);
        (void) fread(acLabel, sizeof(char), iLen, pFSpec);
        acLabel[iLen] = '\0';
        if (strcmp(acLabel, "HEADER_START") != 0)
        {
            (void) fprintf(stderr,
                           "ERROR: Reading header failed!\n");
            CleanUp();
            return YAPP_RET_ERROR;
        }
        iHeaderLen += (sizeof(iLen) + iLen);

        /* parse the rest of the header */
        while (strcmp(acLabel, "HEADER_END") != 0)
        {
            /* read field label length */
            (void) fread(&iLen, sizeof(iLen), 1, pFSpec);
            /* read field label */
            (void) fread(acLabel, sizeof(char), iLen, pFSpec);
            acLabel[iLen] = '\0';
            iHeaderLen += (sizeof(iLen) + iLen);
            if (0 == strcmp(acLabel, "source_name"))
            {
                (void) fread(&iLen, sizeof(iLen), 1, pFSpec);
                (void) fread(stHeader.acPulsar, sizeof(char), iLen, pFSpec);
                stHeader.acPulsar[iLen] = '\0';
                (void) strcpy(acPulsar, stHeader.acPulsar);
                iHeaderLen += (sizeof(iLen) + iLen);
            }
            else if (0 == strcmp(acLabel, "data_type"))
            {
                (void) fread(&stHeader.iDataTypeID,
                             sizeof(stHeader.iDataTypeID),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.iDataTypeID);
            }
            else if (0 == strcmp(acLabel, "nchans"))
            {
                /* read number of channels */
                (void) fread(&stHeader.iNumChans,
                             sizeof(stHeader.iNumChans),
                             1,
                             pFSpec);
                iNumChans = stHeader.iNumChans;
                iHeaderLen += sizeof(stHeader.iNumChans);
            }
            else if (0 == strcmp(acLabel, "fch1"))
            {
                /* read frequency of first channel */
                (void) fread(&stHeader.dFChan1,
                             sizeof(stHeader.dFChan1),
                             1,
                             pFSpec);
                fFCh1 = (float) stHeader.dFChan1;
                iHeaderLen += sizeof(stHeader.dFChan1);
            }
            else if (0 == strcmp(acLabel, "foff"))
            {
                /* read channel bandwidth (labelled frequency offset) */
                (void) fread(&stHeader.dChanBW,
                             sizeof(stHeader.dChanBW),
                             1,
                             pFSpec);
                fChanBW = (float) stHeader.dChanBW;
                iHeaderLen += sizeof(stHeader.dChanBW);
            }
            else if (0 == strcmp(acLabel, "nbits"))
            {
                /* read number of bits per sample */
                (void) fread(&stHeader.iNumBits,
                             sizeof(stHeader.iNumBits),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.iNumBits);
            }
            else if (0 == strcmp(acLabel, "nifs"))
            {
                /* read number of IFs */
                (void) fread(&stHeader.iNumIFs,
                             sizeof(stHeader.iNumIFs),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.iNumIFs);
            }
            else if (0 == strcmp(acLabel, "tsamp"))
            {
                /* read sampling time in seconds */
                (void) fread(&stHeader.dTSamp,
                             sizeof(stHeader.dTSamp),
                             1,
                             pFSpec);
                dTSampInSec = stHeader.dTSamp;
                dTSamp = dTSampInSec * 1e3;     /* in ms */
                iHeaderLen += sizeof(stHeader.dTSamp);
            }
            else if (0 == strcmp(acLabel, "tstart"))
            {
                /* read timestamp of first sample (MJD) */
                (void) fread(&stHeader.dTStart,
                             sizeof(stHeader.dTStart),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.dTStart);
            }
            else if (0 == strcmp(acLabel, "telescope_id"))
            {
                /* read telescope ID */
                (void) fread(&stHeader.iObsID,
                             sizeof(stHeader.iObsID),
                             1,
                             pFSpec);
                (void) YAPP_GetObsNameFromID(stHeader.iObsID, acSite);
                iHeaderLen += sizeof(stHeader.iObsID);
            }
            else if (0 == strcmp(acLabel, "machine_id"))
            {
                /* read backend ID */
                (void) fread(&stHeader.iBackendID,
                             sizeof(stHeader.iBackendID),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.iBackendID);
            }
            else if (0 == strcmp(acLabel, "src_raj"))
            {
                /* read source RA (J2000) */
                (void) fread(&stHeader.dSourceRA,
                             sizeof(stHeader.dSourceRA),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.dSourceRA);
            }
            else if (0 == strcmp(acLabel, "src_dej"))
            {
                /* read source declination (J2000) */
                (void) fread(&stHeader.dSourceDec,
                             sizeof(stHeader.dSourceDec),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.dSourceDec);
            }
            else if (0 == strcmp(acLabel, "az_start"))
            {
                /* read azimuth start */
                (void) fread(&stHeader.dAzStart,
                             sizeof(stHeader.dAzStart),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.dAzStart);
            }
            else if (0 == strcmp(acLabel, "za_start"))
            {
                /* read ZA start */
                (void) fread(&stHeader.dZAStart,
                             sizeof(stHeader.dZAStart),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.dZAStart);
            }
            /* DTS-specific field */
            else if (0 == strcmp(acLabel, "refdm"))
            {
                /* read reference DM */
                (void) fread(&stHeader.dDM, sizeof(stHeader.dDM), 1, pFSpec);
                iHeaderLen += sizeof(stHeader.dDM);
            }
            else if (0 == strcmp(acLabel, "barycentric"))
            {
                /* read barycentric flag */
                (void) fread(&stHeader.iFlagBary,
                             sizeof(stHeader.iFlagBary),
                             1,
                             pFSpec);
                iHeaderLen += sizeof(stHeader.iFlagBary);
            }
            else if (0 == strcmp(acLabel, "FREQUENCY_START"))
            {
                iFlagSplicedData = YAPP_TRUE;

                /* read field label length */
                (void) fread(&iLen, sizeof(iLen), 1, pFSpec);
                /* read field label */
                (void) fread(acLabel, sizeof(char), iLen, pFSpec);
                acLabel[iLen] = '\0';
                iHeaderLen += (sizeof(iLen) + iLen);
                if (0 == strcmp(acLabel, "nchans"))
                {
                    /* read number of channels */
                    (void) fread(&stHeader.iNumChans,
                                 sizeof(stHeader.iNumChans),
                                 1,
                                 pFSpec);
                    iNumChans = stHeader.iNumChans;
                    iHeaderLen += sizeof(stHeader.iNumChans);
                }
                else
                {
                    (void) fprintf(stderr,
                                   "ERROR: Unexpected label %s found!",
                                   acLabel);
                    (void) fclose(pFSpec);
                    CleanUp();
                    return YAPP_RET_ERROR;
                }

                /* allocate memory for the frequency channel array read from
                   the header */
                g_pfFreq = (float *) malloc(sizeof(float) * iNumChans);
                if (NULL == g_pfFreq)
                {
                    perror("malloc - g_pfFreq");
                    (void) fclose(pFSpec);
                    CleanUp();
                    return YAPP_RET_ERROR;
                }

                /* store in the reverse order for plotting later */
                i = iNumChans - 1;
                /* parse frequency channels for spliced data */
                while (strcmp(acLabel, "FREQUENCY_END") != 0)
                {
                    /* read field label length */
                    (void) fread(&iLen, sizeof(iLen), 1, pFSpec);
                    /* read field label */
                    (void) fread(acLabel, sizeof(char), iLen, pFSpec);
                    acLabel[iLen] = '\0';
                    iHeaderLen += (sizeof(iLen) + iLen);
                    if (0 == strcmp(acLabel, "fchannel"))
                    {
                        (void) fread(&dFChan, sizeof(dFChan), 1, pFSpec);
                        g_pfFreq[i] = (float) dFChan;
                        iHeaderLen += sizeof(dFChan);
                    }
                    else
                    {
                        /* print a warning about encountering unknown field label */
                        if (strcmp(acLabel, "FREQUENCY_END") != 0)
                        {
                            (void) fprintf(stderr,
                                           "WARNING: Unknown field label %s "
                                           "encountered!\n", acLabel);
                            (void) fclose(pFSpec);
                            CleanUp();
                            return YAPP_RET_ERROR;
                        }
                    }
                    --i;
                }
            }
            else
            {
                /* print a warning about encountering unknown field label */
                if (strcmp(acLabel, "HEADER_END") != 0)
                {
                    (void) fprintf(stderr,
                                   "WARNING: Unknown field label %s "
                                   "encountered!\n", acLabel);
                }
            }
        }

        /* close the file, it will be opened later for reading data */
        (void) fclose(pFSpec);

        (void) printf("Header length                     : %d\n", iHeaderLen);
        (void) printf("Field name                        : %s\n", acPulsar);
        (void) printf("Observing site                    : %s\n", acSite);
        (void) printf("Number of channels                : %d\n", iNumChans);

        if (fChanBW < 0.0)
        {
            /* make the channel bandwidth positive */
            fChanBW = fabs(fChanBW);
            fFMax = fFCh1;
            fFMin = fFMax - (iNumChans * fChanBW);
        }
        else
        {
            fFMin = fFCh1;
            fFMax = fFMin + (iNumChans * fChanBW);
        }

        if (YAPP_TRUE == iFlagSplicedData)
        {
            /* in spliced data files, the first frequency is always the
               highest - since we have inverted the array, it is the last
               frequency */
            fFMax = g_pfFreq[iNumChans-1];
            /* get the lowest frequency */
            fFMin = g_pfFreq[0];
            /* calculate the channel bandwidth */
            fChanBW = g_pfFreq[1] - g_pfFreq[0];

			/* TODO: Number-of-bands calculation not accurate */
            for (i = 1; i < iNumChans; ++i)
            {
                /*if (fabsf(g_pfFreq[i] - g_pfFreq[i-1]) > fChanBW)*/
                /* kludge: */
                if (fabsf(g_pfFreq[i] - g_pfFreq[i-1]) > (2 * fChanBW))
                {
                    afTicks[iNumBands] = g_pfFreq[i];
                    ++iNumBands;
                    if (YAPP_MAX_NUM_BANDS == iNumBands)
                    {
                        (void) printf("WARNING: "
                                      "Maximum number of bands reached!\n");
                        break;
                    }
                }
            }
            (void) printf("Number of bands                   : %d\n",
                          iNumBands);
        }

        /* TODO: find out the discontinuities and print them as well, also
                 number of spliced bands */

        (void) printf("Channel bandwidth                 : %.10g MHz\n",
                      fChanBW);
        (void) printf("Lowest frequency                  : %.10g MHz\n", fFMin);
        (void) printf("Highest frequency                 : %.10g MHz\n", fFMax);

        (void) printf("Sampling interval                 : %.10g ms\n", dTSamp);
        (void) printf("Timestamp of first sample         : %.16g MJD\n",
                      stHeader.dTStart);
        (void) printf("Number of bits per sample         : %d\n",
                      stHeader.iNumBits);
        (void) printf("Number of IFs                     : %d\n",
                      stHeader.iNumIFs);

        fSampSize = ((float) stHeader.iNumBits) / 8;

        iRet = stat(pcFileSpec, &stFileStats);
        if (iRet != YAPP_RET_SUCCESS)
        {
            (void) fprintf(stderr,
                           "ERROR: Failed to stat %s: %s!\n",
                           pcFileSpec,
                           strerror(errno));
            CleanUp();
            return YAPP_RET_ERROR;
        }
        lDataSizeTotal = (long) stFileStats.st_size - iHeaderLen;
        (void) printf("Duration of data in\n");
        (void) printf("    Bytes                         : %ld\n",
                      (lDataSizeTotal / iNumChans));
        iTimeSamps = (int) (lDataSizeTotal / (iNumChans * fSampSize));
        (void) printf("    Time samples                  : %d\n", iTimeSamps);
        (void) printf("    Time                          : %g s\n",
                      (iTimeSamps * dTSampInSec));

        /* set number of good channels to number of channels - no support for
           SIGPROC ignore files yet */
        iNumGoodChans = iNumChans;
    }

    /* check which of the data processing specification modes - percentage or
       time - has been selected by the user, and calculate bytes to skip and
       read */
    if (PROC_SPEC_TIME == iProcSpec)
    {
        if (0 == iDataProcTime)
        {
            iDataProcTime = iTimeSamps * dTSampInSec;
        }

        /* ensure that the input time duration is less than the length of the
           data */
        if (((double) iDataProcTime) > (iTimeSamps * dTSampInSec))
        {
            (void) fprintf(stderr,
                           "ERROR: Input time is longer than length of "
                           "data!\n");
            CleanUp();
            return YAPP_RET_ERROR;
        }

        lBytesToSkip = (long) ((iDataSkipTime * 1000.0 / dTSamp)
                                                        /* number of samples */
                               * iNumChans
                               * fSampSize);
        lBytesToProc = (long) ((iDataProcTime * 1000.0 / dTSamp)
                                                        /* number of samples */
                               * iNumChans
                               * fSampSize);
    }
    else    /* if it is not selected, or percentage is selected, use percentage
               mode */
    {
        lBytesToSkip = (long) (floorf(iTimeSamps
                                     * (((float) iDataSkipPercent) / 100))
                                                        /* number of samples */
                               * iNumChans
                               * fSampSize);
        lBytesToProc = (long) (ceilf(iTimeSamps
                                    * (((float) iDataProcPercent) / 100))
                                                        /* number of samples */
                               * iNumChans
                               * fSampSize);
    }

    /* if lBytesToSkip is not a multiple of the block size, make it one */
    if (((float) lBytesToSkip / iBlockSize) - (lBytesToSkip / iBlockSize) != 0)
    {
        (void) printf("WARNING: Bytes to skip not a multiple of block size! ");
        lBytesToSkip -= (((float) lBytesToSkip / iBlockSize)
                         - (lBytesToSkip / iBlockSize)) * iBlockSize;
        (void) printf("Newly calculated size of data to be skipped: %ld "
                      "bytes\n",
                      lBytesToSkip);
    }

    if (lBytesToSkip >= lDataSizeTotal)
    {
        (void) printf("WARNING: Data to be skipped is greater than or equal to "
                      "the size of the file! Terminating.\n");
        CleanUp();
        return YAPP_RET_SUCCESS;
    }

    if ((lBytesToSkip + lBytesToProc) > lDataSizeTotal)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        lBytesToProc = lDataSizeTotal - lBytesToSkip;
        (void) printf("Newly calculated size of data to be processed: %ld "
                      "bytes\n",
                      lBytesToProc);
    }

    iTimeSampsSkip = (int) (lBytesToSkip / (iNumChans * fSampSize));
    (void) printf("Skipping\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n",
                  lBytesToSkip,
                  lDataSizeTotal,
                  iTimeSampsSkip,
                  iTimeSamps,
                  (iTimeSampsSkip * dTSampInSec),
                  (iTimeSamps * dTSampInSec));

    iTimeSampsToProc = (int) (lBytesToProc / (iNumChans * fSampSize));
    iNumReads = (int) ceilf(((float) iTimeSampsToProc) / iBlockSize);
    iTotNumReads = iNumReads;

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = iNumChans * iBlockSize;
    iDataSizePerBlock = (int) (fSampSize * iTotSampsPerBlock);

    (void) printf("Processing\n"
                  "    %ld of %ld bytes\n"
                  "    %d of %d time samples\n"
                  "    %.10g of %.10g seconds\n"
                  "in %d reads with block size %d time samples...\n",
                  lBytesToProc,
                  lDataSizeTotal,
                  iTimeSampsToProc,
                  iTimeSamps,
                  (iTimeSampsToProc * dTSampInSec),
                  (iTimeSamps * dTSampInSec),
                  iNumReads,
                  iBlockSize);

    /* calculate the threshold */
    dNumSigmas = YAPP_CalcThresholdInSigmas(iTimeSampsToProc);
    if ((double) YAPP_RET_ERROR == dNumSigmas)
    {
        (void) fprintf(stderr, "ERROR: Threshold calculation failed!\n");
        CleanUp();
        return YAPP_RET_ERROR;
    }
    fStatBW = iNumGoodChans * fChanBW;  /* in MHz */
    (void) printf("Usable bandwidth                  : %g MHz\n", fStatBW);
    fNoiseRMS = 1.0 / sqrt(fStatBW * dTSamp * 1e3);
    (void) printf("Expected noise RMS                : %g\n", fNoiseRMS);
    fThreshold = (float) (dNumSigmas * fNoiseRMS);
    (void) printf("Threshold                         : %g\n", fThreshold);
    /* calculate the minimum SNR */
    fSNRMin = fThreshold / fNoiseRMS;

    /* allocate memory for the time sample goodness flag array */
    g_pcIsTimeGood = (char *) malloc(sizeof(char) * iTimeSampsToProc);
    if (NULL == g_pcIsTimeGood)
    {
        perror("malloc - g_pcIsTimeGood");
        CleanUp();
        return YAPP_RET_ERROR;
    }
    /* set all elements to 'YAPP_TRUE' */
    (void) memset(g_pcIsTimeGood, YAPP_TRUE, iTimeSampsToProc);

    /* open the dynamic spectrum data file for reading */
    pFSpec = fopen(pcFileSpec, "r");
    if (NULL == pFSpec)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileSpec,
                       strerror(errno));
        CleanUp();
        return YAPP_RET_ERROR;
    }

    /* allocate memory for the buffer, based on the number of channels and time
       samples */
    g_pfBuf = (float *) malloc(sizeof(float) * iNumChans * iBlockSize);
    if (NULL == g_pfBuf)
    {
        perror("malloc - g_pfBuf");
        (void) fclose(pFSpec);
        CleanUp();
        return YAPP_RET_ERROR;
    }

    if (1 == iNumReads)
    {
        cIsLastBlock = YAPP_TRUE;
    }

    if (YAPP_FORMAT_FIL == iFormat)
    {
        /* TODO: Need to do this only if the file contains the header */
        /* skip the header */
        (void) fseek(pFSpec, (long) iHeaderLen, SEEK_SET);
        /* skip data, if any are to be skipped */
        (void) fseek(pFSpec, lBytesToSkip, SEEK_CUR);
    }
    else
    {
        /* skip data, if any are to be skipped */
        (void) fseek(pFSpec, lBytesToSkip, SEEK_SET);
    }

    /* open the PGPLOT graphics device */
    iRet = cpgopen(PG_DEV);
    if (iRet <= 0)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening graphics device %s failed!\n",
                       PG_DEV);
        (void) fclose(pFSpec);
        CleanUp();
        return YAPP_RET_ERROR;
    }

    /* set the background colour to white and the foreground colour to
       black, if user requires so */
    if (YAPP_TRUE == iInvCols)
    {
        cpgscr(0, 1.0, 1.0, 1.0);
        cpgscr(1, 0.0, 0.0, 0.0);
    }

    /* set up the plot's X-axis */
    g_pfXAxis = (float *) malloc(sizeof(float) * iBlockSize);
    if (NULL == g_pfXAxis)
    {
        perror("malloc - g_pfXAxis");
        cpgclos();
        (void) fclose(pFSpec);
        CleanUp();
        return YAPP_RET_ERROR;
    }

    if (YAPP_FALSE == iFlagSplicedData)
    {
        /* set up the image plot's Y-axis (frequency) */
        g_pfFreq = (float *) malloc(sizeof(float) * iNumChans);
        if (NULL == g_pfFreq)
        {
            perror("malloc - g_pfFreq");
            cpgclos();
            (void) fclose(pFSpec);
            CleanUp();
            return YAPP_RET_ERROR;
        }
        for (i = 0; i < iNumChans; ++i)
        {
            g_pfFreq[i] = fFMin + i * fChanBW;
        }
    }

    /* calculate the tick step sizes */
    fXStep = (int) ((((iBlockSize - 1) * dTSampInSec) - 0)
                    / PG_TICK_STEPS_X);
    if (YAPP_TRUE == iFlagSplicedData)
    {
        //test
        iNumTicksY = iNumBands + 1;
        //iNumTicksY = 0;
        //iNumTicksY = 5;
    }
    fYStep = (int) ((fFMax - fFMin) / iNumTicksY);

    /* allocate memory for the cpgimag() plotting buffer */
    g_pfPlotBuf = (float *) malloc(sizeof(float) * iNumChans * iBlockSize);
    if (NULL == g_pfPlotBuf)
    {
        perror("malloc - g_pfPlotBuf");
        cpgclos();
        (void) fclose(pFSpec);
        CleanUp();
        return YAPP_RET_ERROR;
    }

    afTM[0] = 1;
    afTM[1] = 1;
    afTM[2] = 0;
    afTM[3] = 1;
    afTM[4] = 0;
    afTM[5] = 1;

    while (iNumReads > 0)
    {
        /* read data */
        (void) printf("\rReading data block %d.", iReadBlockCount);
        (void) fflush(stdout);
        iReadItems = YAPP_ReadData(pFSpec,
                                   g_pfBuf,
                                   fSampSize,
                                   iTotSampsPerBlock);
        if (YAPP_RET_ERROR == iReadItems)
        {
            (void) fprintf(stderr, "ERROR: Reading data failed!\n");
            cpgclos();
            (void) fclose(pFSpec);
            CleanUp();
            return YAPP_RET_ERROR;
        }
        pfSpectrum = g_pfBuf;
        --iNumReads;
        ++iReadBlockCount;

        if (iReadItems < iTotSampsPerBlock)
        {
            iDiff = (iNumChans * iBlockSize) - iReadItems;

            /* reset remaining elements to '\0' */
            (void) memset((g_pfBuf + iReadItems),
                          '\0',
                          (sizeof(float) * iDiff));
        }

        /* calculate the number of time samples in the block - this may not
           be iBlockSize for the last block, and should be iBlockSize for
           all other blocks */
        iNumSamps = iReadItems / iNumChans;

        /* get the actual count of read samples, inclusive of those in the
           first buffer */
        iSecBufReadSampCount = iReadBlockCount * iBlockSize;

        if (YAPP_FORMAT_SPEC == iFormat)
        {
            /* flag bad time sections, and if required, normalise within the
               beam flip time section and perform gain correction */
            for (i = 0; i < iNumSamps; ++i)
            {
                dTNow += dTSampInSec;   /* in s */

                if ((dTNow >= (*g_padBadTimes)[iBadTimeSect][BADTIME_BEG])
                    && (dTNow <= (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
                {
                    cIsInBadTimeRange = YAPP_TRUE;
                    g_pcIsTimeGood[(iReadBlockCount-1)*iBlockSize+i]
                        = YAPP_FALSE;
                }

                if ((YAPP_TRUE == cIsInBadTimeRange)
                    && (dTNow > (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
                {
                    cIsInBadTimeRange = YAPP_FALSE;
                    ++iBadTimeSect;
                }

                /* get the beam flip time section corresponding to this
                   sample */
                if (dTNow > dTNextBF)
                {
                    dTNextBF += dTBFInt;

                    if (iTimeSect >= iBFTimeSects)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Beam flip time section anomaly "
                                       "detected!\n");
                        cpgclos();
                        (void) fclose(pFSpec);
                        CleanUp();
                        return YAPP_RET_ERROR;
                    }
                    ++iTimeSect;
                }

                pfTimeSectGain = g_pfBFGain + iTimeSect * iNumChans;
                pfSpectrum = g_pfBuf + i * iNumChans;
                for (j = 0; j < iNumChans; ++j)
                {
                    if (g_pcIsChanGood[j])
                    {
                        if (fClipLevel != 0.0)
                        {
                            if (pfSpectrum[j] > ((dNumSigmas + fClipLevel)
                                                 * fNoiseRMS))
                            {
                                pfSpectrum[j] = (dNumSigmas + fClipLevel)
                                                * fNoiseRMS;
                            }
                            else if (pfSpectrum[j] < -((dNumSigmas + fClipLevel)
                                                       * fNoiseRMS))
                            {
                                pfSpectrum[j] = -((dNumSigmas + fClipLevel)
                                                  * fNoiseRMS);
                            }
                        }

                        pfSpectrum[j] = (pfSpectrum[j]
                                         / g_pfBFTimeSectMean[iTimeSect])
                                        - pfTimeSectGain[j];
                    }
                    else    /* remove bad channels */
                    {
                        pfSpectrum[j] = 0.0;
                    }
                }
            }
        }
        else if (YAPP_FORMAT_FIL == iFormat)
        {
            /* perform clipping, if required */
            for (i = 0; i < iNumSamps; ++i)
            {
                pfSpectrum = g_pfBuf + i * iNumChans;
                for (j = 0; j < iNumChans; ++j)
                {
                    if (fClipLevel != 0.0)
                    {
                        if (pfSpectrum[j] > ((dNumSigmas + fClipLevel)
                                             * fNoiseRMS))
                        {
                            pfSpectrum[j] = (dNumSigmas + fClipLevel)
                                            * fNoiseRMS;
                        }
                        else if (pfSpectrum[j] < -((dNumSigmas + fClipLevel)
                                                   * fNoiseRMS))
                        {
                            pfSpectrum[j] = -((dNumSigmas + fClipLevel)
                                              * fNoiseRMS);
                        }
                    }
                }
            }
        }

        fDataMin = pfSpectrum[0];
        fDataMax = pfSpectrum[0];
        for (j = 0; j < iBlockSize; ++j)
        {
            pfSpectrum = g_pfBuf + j * iNumChans;
            for (k = 0; k < iNumChans; ++k)
            {
                if (pfSpectrum[k] < fDataMin)
                {
                    fDataMin = pfSpectrum[k];
                }
                if (pfSpectrum[k] > fDataMax)
                {
                    fDataMax = pfSpectrum[k];
                }
            }
        }

        #ifdef DEBUG
        (void) printf("Minimum value of data             : %g\n",
                      fDataMin);
        (void) printf("Maximum value of data             : %g\n",
                      fDataMax);
        #endif

        if (-fThreshold > fDataMin)
        {
            fColMin = -fThreshold;
        }
        else
        {
            fColMin = fDataMin;
        }
        if (fThreshold < fDataMax)
        {
            fColMax = fThreshold;
        }
        else
        {
            fColMax = fDataMax;
        }

        iFlagBW = YAPP_FALSE;

        #ifdef _FC_F77_    /* if using Fortran 77 compiler */
        set_colours__(&iFlagBW, &fColMin, &fColMax);
        #else           /* for Fortran 95 */
        set_colours_(&iFlagBW, &fColMin, &fColMax);
        #endif
        /* DEV:
        SetColourMap(iFlagBW, fColMin, fColMax); */

        /* get the transpose of the two-dimensional array */
        i = 0;
        j = 0;
        k = 0;
        for (l = 0; l < iBlockSize; ++l)
        {
            pfSpectrum = g_pfBuf + l * iNumChans;
            for (m = 0; m < iNumChans; ++m)
            {
                g_pfPlotBuf[j] = pfSpectrum[m];
                j = k + i * iBlockSize;
                ++i;
            }
            i = 0;
            j = ++k;
        }

        cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
        cpgswin(1, (iBlockSize - 2), 1, (iNumChans - 2));
        cpgbox("C", 0.0, 0, "C", 0.0, 0);
        for (i = 0; i < iBlockSize; ++i)
        {
            g_pfXAxis[i] = (float) (((iReadBlockCount - 1)
                                     * iBlockSize
                                     * dTSampInSec)
                                    + (i * dTSampInSec));
        }
        cpgaxis("N",
                1, 1,
                (iBlockSize - 2), 1,
                g_pfXAxis[1], g_pfXAxis[iBlockSize-2],
                fXStep,
                0,
                0.0,
                0.4,
                1.0,
                0.8,
                0);
        cpgaxis("N",
                1, 1,
                1, (iNumChans - 2),
                g_pfFreq[1], g_pfFreq[iNumChans-2],
                fYStep,
                0,
                0.4,
                0.0,
                1.0,
                -0.8,
                0);
        cpglab("Time (s)", "Frequency (MHz)", "Dynamic Spectrum");
        cpgimag(g_pfPlotBuf,
                iBlockSize,
                iNumChans,
                1,
                (iBlockSize - 2),
                1,
                (iNumChans - 2),
                fDataMin,
                fDataMax,
                afTM);
      #if 0
      /* draw tick marks at band boundaries */
        {
        float fFrac = 0.0;
            fFrac = -1;
        for (i = 0; i < iNumBands; ++i)
        {
           // float fFrac = (afTicks[i] - g_pfFreq[1])
             //             /(g_pfFreq[iNumChans-2] - g_pfFreq[1]);

            printf("************ fFrac = %g\n", fFrac);
            printf("%g %g\n", g_pfFreq[1], g_pfFreq[iNumChans-1]);

            cpgtick(g_pfXAxis[1],
                    g_pfFreq[1],
                    g_pfXAxis[1],
                    g_pfFreq[iNumChans-2],
                    fFrac,
                    0,
                    1,
                    -0.75,
                    0,
                    "blah");
            //fFrac += 0.25;

        }
        }
        #endif
        cpgwedg("RI", 1.0, 5.0, fDataMin, fDataMax, "");

        if (!(cIsLastBlock))
        {
            if (!(cIsNonInteractive))
            {
                /* draw the 'next' button */
                cpgsvp(PG_VP_BUT_ML, PG_VP_BUT_MR, PG_VP_BUT_MB, PG_VP_BUT_MT);
                cpgswin(PG_BUT_L, PG_BUT_R, PG_BUT_B, PG_BUT_T);
                cpgsci(PG_BUT_FILLCOL); /* set the fill colour */
                cpgrect(PG_BUT_L, PG_BUT_R, PG_BUT_B, PG_BUT_T);
                cpgsci(0);  /* set colour index to white */
                cpgtext(PG_BUT_TEXT_L, PG_BUT_TEXT_B, "Next");

                fButX = (PG_BUT_R - PG_BUT_L) / 2;
                fButY = (PG_BUT_T - PG_BUT_B) / 2;

                while (YAPP_TRUE)
                {
                    iRet = cpgcurs(&fButX, &fButY, &cCurChar);
                    if (0 == iRet)
                    {
                        (void) fprintf(stderr,
                                       "WARNING: "
                                       "Reading cursor parameters failed!\n");
                        break;
                    }

                    if (((fButX >= PG_BUT_L) && (fButX <= PG_BUT_R))
                        && ((fButY >= PG_BUT_B) && (fButY <= PG_BUT_T)))
                    {
                        /* animate button click */
                        cpgsci(PG_BUT_FILLCOL);
                        cpgtext(PG_BUT_TEXT_L, PG_BUT_TEXT_B, "Next");
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUT_CL_TEXT_L, PG_BUT_CL_TEXT_B, "Next");
                        (void) usleep(PG_BUT_CL_SLEEP);
                        cpgsci(PG_BUT_FILLCOL); /* set colour index to fill
                                                   colour */
                        cpgtext(PG_BUT_CL_TEXT_L, PG_BUT_CL_TEXT_B, "Next");
                        cpgsci(0);  /* set colour index to white */
                        cpgtext(PG_BUT_TEXT_L, PG_BUT_TEXT_B, "Next");
                        cpgsci(1);  /* reset colour index to black */
                        (void) usleep(PG_BUT_CL_SLEEP);

                        break;
                    }
                }
            }
            else
            {
                /* pause before erasing */
                (void) sleep(PG_PLOT_SLEEP);
            }
            /* TODO: make the transition smoother by erasing only the axes */
            cpgeras();
        }

        if (1 == iNumReads)
        {
            cIsLastBlock = YAPP_TRUE;
        }
    }

    (void) printf("DONE!\n");

    cpgclos();

    (void) fclose(pFSpec);
    CleanUp();

    return YAPP_RET_SUCCESS;
}

/*
 * Sets the colour map
 */
int SetColourMap(int iIsMonochrome, int iIsColInv, float fColMin, float fColMax)
{
    int iColMin = 0;
    int iColMax = 0;
    char acQItem[LEN_GENSTRING] = {0};
    int iLenQVal = 0;

    /* query colour capability */
    cpgqcol(&iColMin, &iColMax);
    if (!(iIsMonochrome))   /* request for colour */
    {
        if (1 == iColMax)   /* device has no colour capability */
        {
            (void) printf("WARNING: Device has no colour capability\n!");
            return YAPP_RET_SUCCESS;
        }
    }

    /* invert colours for hardcopy device, if it is not inverted already */
    if (!(iIsColInv))
    {
        /* query hardcopy status */
        cpgqinf("HARDCOPY", acQItem, &iLenQVal);
        if (0 == strcmp(acQItem, "YES"))
        {
            /* this is a harcopy device, so invert colours */
        }
    }

    return YAPP_RET_SUCCESS;
}

/*
 * Cleans up all allocated memory
 */
void CleanUp()
{
    if (g_pfBuf != NULL)
    {
        free(g_pfBuf);
        g_pfBuf = NULL;
    }
    if (g_pdDelayTab != NULL)
    {
        free(g_pdDelayTab);
        g_pdDelayTab = NULL;
    }
    if (g_padBadTimes != NULL)
    {
        free(g_padBadTimes);
        g_padBadTimes = NULL;
    }
    if (g_pfBFGain != NULL)
    {
        free(g_pfBFGain);
        g_pfBFGain = NULL;
    }
    if (g_pfBFTimeSectMean != NULL)
    {
        free(g_pfBFTimeSectMean);
        g_pfBFTimeSectMean = NULL;
    }
    if (g_pcIsChanGood != NULL)
    {
        free(g_pcIsChanGood);
        g_pcIsChanGood = NULL;
    }
    if (g_pcIsTimeGood != NULL)
    {
        free(g_pcIsTimeGood);
        g_pcIsTimeGood = NULL;
    }
    if (g_pfPlotBuf != NULL)
    {
        free(g_pfPlotBuf);
        g_pfPlotBuf = NULL;
    }
    if (g_pfXAxis != NULL)
    {
        free(g_pfXAxis);
        g_pfXAxis = NULL;
    }
    if (g_pfFreq != NULL)
    {
        free(g_pfFreq);
        g_pfFreq = NULL;
    }

    return;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <dynamic-spectrum-data-file>\n",
                  pcProgName);
    (void) printf("    -h  --help                           ");
    (void) printf("Display this usage information\n");
    (void) printf("    -s  --data-skip-percent <percentage> ");
    (void) printf("The percentage of data to be skipped\n");
    (void) printf("    -S  --data-skip-time <time>          ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                         ");
    (void) printf("skipped\n");
    (void) printf("    -p  --data-proc-percent <percentage> ");
    (void) printf("The percentage of data to be processed\n");
    (void) printf("                                         ");
    (void) printf("(default is 100)\n");
    (void) printf("    -P  --data-proc-time <time>          ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                         ");
    (void) printf("processed\n");
    (void) printf("                                         ");
    (void) printf("(default is all)\n");
    (void) printf("    -b  --block-size <samples>           ");
    (void) printf("Number of samples read in one block\n");
    (void) printf("                                         ");
    (void) printf("(default is 4096 samples)\n");
    (void) printf("    -c  --clip-level <level>             ");
    (void) printf("Number of sigmas above threshold; will\n");
    (void) printf("                                         ");
    (void) printf("clip anything above this level\n");
    (void) printf("    -i  --invert                         ");
    (void) printf("Invert background and foreground\n");
    (void) printf("                                         ");
    (void) printf("colours in plots\n");
    (void) printf("    -n  --non-interactive                ");
    (void) printf("Run in non-interactive mode\n");
    (void) printf("    -v  --version                        ");
    (void) printf("Display the version\n");

    return;
}

