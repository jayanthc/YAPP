/**
 * @file gendispdata.c
 * Generate dispersed-count data for testing dedispersion programs.
 *
 * @verbatim
 * Usage: gendispdata [options] <spec-file>
 *     -h  --help                           Display this usage information
 *     -t  --time                           Duration of data, in samples
 *     -c  --channels                       Number of frequency channels
 *     -d  --delay                          Delay between frequency channels,
 *                                          in samples
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2009.06.26
 */

#include "sps.h"

#define TEST_SOURCE     "TESTSRC"
#define TEST_SITE       "TESTSITE"
#define FLAG_CH_GOOD    1

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* the following is global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
//float *g_pfBFTimeSectMean = NULL;
float *g_pfDispData = NULL;

int main(int argc, char *argv[])
{
    FILE *pFDispData = NULL;
    FILE *pFDispDataCfg = NULL;
    char *pcFileSpec = NULL;
    char acFileCfg[LEN_GENSTRING] = {0};
    int iTimeSamps = 0;
    int iNumChans = 0;
    int iDelay = 0;
    double dTSamp = 0.0;        /* holds sampling time in ms */
    int iBytesPerFrame = 0;
    float fFCentre = 0.0;
    float fBW = 0.0;
    int iChanBeg = 0;
    int iChanEnd = 0;
    char acPulsar[LEN_GENSTRING] = {0};
    int iDay = 0;
    int iMonth = 0;
    int iYear = 0;
    int iHour = 0;
    int iMin = 0;
    float fSec = 0.0;
    char acSite[LEN_GENSTRING] = {0};
    double dTNextBF = 0.0;
    double dTBFInt = 0.0;
    int iBFTimeSects = 0;
    int iNumBadTimes = 0;
    float *pfSpectrum = NULL;
    int iRet = SPS_RET_SUCCESS;
    int i = 0;
    int j = 0;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "ht:c:d:v";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "time",                   1, NULL, 't' },
        { "channels",               1, NULL, 'c' },
        { "delay",                  1, NULL, 'd' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return SPS_RET_SUCCESS;

            case 't':   /* -t or --time */
                /* set option */
                iTimeSamps = atoi(optarg);
                break;

            case 'c':   /* -c or --channels */
                /* set option */
                iNumChans = atoi(optarg);
                break;

            case 'd':   /* -d or --delay */
                /* set option */
                iDelay = atoi(optarg);
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return SPS_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return SPS_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return SPS_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = SPS_RegisterSignalHandlers();
    if (iRet != SPS_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return SPS_RET_ERROR;
    }

    /* get the input filename */
    pcFileSpec = argv[optind];

    /* NOTE: writing data in Desh's 'spec' file format + associated 'spec_cfg'
       file format */
    pFDispData = fopen(pcFileSpec, "w");
    if (NULL == pFDispData)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileSpec,
                       strerror(errno));
        CleanUp();
        return SPS_RET_ERROR;
    }

    g_pfDispData = (float *) malloc(sizeof(float) * iNumChans * iTimeSamps);
    if (NULL == g_pfDispData)
    {
        perror("malloc - g_pfBuf0");
        (void) fclose(pFDispData);
        CleanUp();
        return SPS_RET_ERROR;
    }

    (void) printf("Generating data with\n");
    (void) printf("    Duration                      : %d samples\n",
                  iTimeSamps);
    (void) printf("    Number of frequency channels  : %d\n", iNumChans);
    (void) printf("    Delay between channels        : %d samples\n", iDelay);

    for (i = 0; i < iTimeSamps; ++i)
    {
        pfSpectrum = g_pfDispData + i * iNumChans;
        for (j = 0; j < iNumChans; ++j)
        {
            pfSpectrum[j] = (float) (i + j * iDelay);
        }
        (void) fwrite(pfSpectrum, sizeof(float), iNumChans, pFDispData);
    }

    (void) printf("Data generated successfully.\n");

    free(g_pfDispData);
    (void) fclose(pFDispData);

    /* build the 'cfg' file name from the 'spec' file name, and open it */
    (void) strcpy(acFileCfg, pcFileSpec);
    (void) strcat(acFileCfg, SUFFIX_CFG);
    pFDispDataCfg = fopen(acFileCfg, "w");
    if (NULL == pFDispDataCfg)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       acFileCfg,
                       strerror(errno));
        return SPS_RET_ERROR;
    }

    dTSamp = 1.0;                               /* in ms */
    iBytesPerFrame = iNumChans * sizeof(float);
    fFCentre = 34.5;                            /* in MHz */
    fBW = 1000;                                 /* in kHz */
    iChanBeg = 1;
    iChanEnd = iNumChans;
    (void) strcpy(acPulsar, TEST_SOURCE);
    iDay = 1;
    iMonth = 1;
    iYear = 1970;
    iHour = 0;
    iMin = 0;
    fSec = 0.0;
    (void) strcpy(acSite, TEST_SITE);
    dTNextBF = iTimeSamps * dTSamp / 1000.0;    /* in s */
    dTBFInt = dTNextBF;                         /* in s */

    /* write the first few parameters to the 'cfg' file */
    (void) fprintf(pFDispDataCfg,
                   " %.10g\n%d\n%g\n%g\n%d %d\n%s\n%d %d %d\n%d %d %g\n%s\n%.10g %.10g\n",
                   dTSamp,          /* in ms */
                   iBytesPerFrame,  /* iNumChans * sizeof(float) */
                   fFCentre,        /* in MHz */
                   fBW,             /* in kHz */
                   iChanBeg,
                   iChanEnd,
                   acPulsar,
                   iDay,
                   iMonth,
                   iYear,
                   iHour,
                   iMin,
                   fSec,
                   acSite,
                   dTNextBF,        /* in s */
                   dTBFInt);        /* in s */

    /* write the channel goodness flags - all channels are good */
    for (i = 0; i < iNumChans; ++i)
    {
        (void) fprintf(pFDispDataCfg, " %d", FLAG_CH_GOOD);
        if (0 == ((i + 1) % 40))
        {
            (void) fprintf(pFDispDataCfg, "\n");
        }
    }

    /* write the band flip information - no band flip */
    iBFTimeSects = 1;
    (void) fprintf(pFDispDataCfg, " %d", iBFTimeSects);
    /* find the mean of the data */
    for (i = 0; i < iBFTimeSects; ++i)
    {
        //(void) fprintf(pFDispDataCfg, " %g", g_pfBFTimeSectMean[i]);
        (void) fprintf(pFDispDataCfg, " %g", 1.0);
    }
    /* unity band flip gain */
    for (i = 0; i < (iNumChans * iBFTimeSects); ++i)
    {
        (void) fprintf(pFDispDataCfg, " %g", 1.0);
    }

    /* write the bad time section information - no bad time sections */
    iNumBadTimes = 0;
    (void) fprintf(pFDispDataCfg, " %d", iNumBadTimes);

    (void) fclose(pFDispDataCfg);
    return SPS_RET_SUCCESS;
}

/*
 * Cleans up all allocated memory
 */
void CleanUp()
{
    return;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <spec-file>\n", pcProgName);
    (void) printf("    -h  --help                           ");
    (void) printf("Display this usage information\n");
    (void) printf("    -t  --time                           ");
    (void) printf("Duration of data, in samples\n");
    (void) printf("    -c  --channels                       ");
    (void) printf("Number of frequency channels\n");
    (void) printf("    -d  --delay                          ");
    (void) printf("Delay between frequency channels,\n");
    (void) printf("                                         ");
    (void) printf("in samples\n");
    (void) printf("    -v  --version                        ");
    (void) printf("Display the version\n");

    return;
}

