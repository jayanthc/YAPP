/**
 * @file killrfi.c
 * Program to remove swept-frequency RFI in input data.
 *
 * @verbatim
 * Usage: killrfi [options] <spec-file>
 *     -h  --help                           Display this usage information
 *     -d  --dm <dm>                        The quasi-DM at which the RFI is
 *                                          'dispersed'
 *     -s  --data-skip-percent <percentage> The percentage of data to be skipped
 *     -S  --data-skip-time <time>          The length of data in seconds, to be
 *                                          skipped
 *     -p  --data-proc-percent <percentage> The percentage of data to be
 *                                          processed
 *                                          (default is 100)
 *     -P  --data-proc-time <time>          The length of data in seconds, to be
 *                                          processed
 *                                          (default is all)
 *     -b  --block-size <size>              Size of each file read/write in
 *                                          bytes
 *     -o  --no-plots                       Run without displaying plots
 *     -f  --plot-to-file                   Plot to a PostScript file, instead
 *                                          of the screen
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2009.07.13
 */

/* TODO: Non-Gauribidanur-data (ORT & MST) reads nan or inf for the last
   few samples of data */

#include "sps.h"

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

int g_iDispPlots = SPS_TRUE;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
double *g_pdDelayTab = NULL;
char *g_pcIsChanGood = NULL;
char *g_pcIsTimeGood = NULL;
float *g_pfBFTimeSectMean = NULL;
float *g_pfBFGain = NULL;
double (*g_padBadTimes)[][NUM_BAD_BOUNDS] = NULL;
float *g_pfBuf0 = NULL;
float *g_pfBuf1 = NULL;
float *g_pfPlotBuf = NULL;
float *g_pfCleanSpec = NULL;
float *g_pfXAxis = NULL;

int main(int argc, char *argv[])
{
    FILE *pFSpec = NULL;
    FILE *pFCfg = NULL;
    FILE *pFCleanSpec = NULL;
    char *pcFileSpec = NULL;
    char acFileCfg[LEN_GENSTRING] = {0};
    char acFileCleanSpec[LEN_GENSTRING] = {0};
    char cIsPlotToFile = SPS_FALSE;
    int iDataSkipPercent = DEF_SKIP_PERCENT;
    int iDataSkipTime = DEF_SKIP_TIME;
    int iDataProcPercent = DEF_PROC_PERCENT;
    int iDataProcTime = DEF_PROC_TIME;
    int iProcSpec = PROC_SPEC_NOTSEL;   /* by default, the processing
                                           specification is not selected */
    char cIsDMGiven = SPS_FALSE;
    int iChanGoodness = (int) SPS_TRUE;
    double dDelay = 0.0;
    double dDM = 0.0;
    float fFMin = 0.0;
    float fFMax = 0.0;
    float fChanBW = 0.0;
    int iMaxOffset = 0;
    int iNumChans = 0;
    int iTotSampsPerBlock = 0;  /* iNumChans * iBlockSize */
    int iDataSizePerBlock = 0;  /* sizeof(float) * iNumChans * iBlockSize */
    int iNumGoodChans = 0;
    char cIsBandFlipped = SPS_FALSE;
    float fStatBW = 0.0;
    float fNoiseRMS = 0.0;
    float fThreshold = 0.0;
    double dNumSigmas = 0.0;
    float fF1 = 0.0;
    float fF2 = 0.0;
    double dTSamp = 0.0;        /* holds sampling time in ms */
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    double dMaxDelay = 0.0;
    int iBytesPerFrame = 0;
    float fFCentre = 0.0;
    float fBW = 0.0;
    int iChanBeg = 0;
    int iChanEnd = 0;
    char acPulsar[LEN_GENSTRING] = {0};
    int iDay = 0;
    int iMonth = 0;
    int iYear = 0;
    int iHour = 0;
    int iMin = 0;
    float fSec = 0.0;
    char acSite[LEN_GENSTRING] = {0};
    double dTNextBF = 0.0;
    double dTBFInt = 0.0;
    int iBFTimeSects = 0;
    float *pfTimeSectGain = NULL;
    int iNumBadTimes = 0;
    double dTNow = 0.0;
    int iTimeSect = 0;
    int iBadTimeSect = 0;
    char cIsInBadTimeRange = SPS_FALSE;
    float *pfPriBuf = NULL;
    float *pfSecBuf = NULL;
    float *pfSpectrum = NULL;
    float *pfCleanSpectrum = NULL;
    float *pfOffsetSpec = NULL;
    int iPrimaryBuf = BUF_0;
    int iOffset = 0;
    int iBytesToSkip = 0;
    int iBytesToProc = 0;
    int iTimeSamps = 0;
    int iTimeSampsSkip = 0;
    int iBlockSize = DEF_SIZE_BLOCK;
    int iNumReads = 0;
    int iTotNumReads = 0;
    int iReadBlockCount = 0;
    int iReadSmpCount = 0;         /* (iReadBlockCount - 1) * iBlockSize */
    int iSecBufReadSampCount = 0;   /* iReadBlockCount * iBlockSize */
    char cIsLastBlock = SPS_FALSE;
    struct stat stFileStats = {0};
    int iRet = SPS_RET_SUCCESS;
    int iFlagBW = 0;
    float afTM[6] = {0.0};
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    int iReadItems = 0;
    char acDev[LEN_GENSTRING] = {0};
    char *pcFilename = NULL;
    float fColMin = 0.0;
    float fColMax = 0.0;
    int iNumSamps = 0;
    int iDiff = 0;
    int i = 0;
    int j = 0;
    int k = 0;
    int l = 0;
    int m = 0;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hd:s:S:p:P:b:ofv";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "dm",                     1, NULL, 'd' },
        { "data-skip-percent",      1, NULL, 's' },
        { "data-skip-time",         1, NULL, 'S' },
        { "data-proc-percent",      1, NULL, 'p' },
        { "data-proc-time",         1, NULL, 'P' },
        { "block-size",             1, NULL, 'b' },
        { "no-plots",               0, NULL, 'o' },
        { "plot-to-file",           0, NULL, 'f' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return SPS_RET_SUCCESS;

            case 'd':   /* -n or --dm */
                /* set option */
                dDM = atof(optarg);
                cIsDMGiven = SPS_TRUE;
                break;

            case 's':   /* -s or --data-skip-percent */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_PERCENT == iProcSpec))
                {
                    iDataSkipPercent = atoi(optarg);
                    if (iDataSkipPercent > 100)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Data skip percentage should be "
                                       "less than 100!\n");
                        PrintUsage(pcProgName);
                        return SPS_RET_ERROR;
                    }

                    iProcSpec = PROC_SPEC_PERCENT;
                }
                else    /* if the specification mode is time, not percentage */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return SPS_RET_ERROR;
                }
                break;

            case 'S':   /* -S or --data-skip-time */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_TIME == iProcSpec))
                {
                    iDataSkipTime = atoi(optarg);
                    iProcSpec = PROC_SPEC_TIME;
                }
                else    /* if the specification mode is percentage, not time */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return SPS_RET_ERROR;
                }
                break;

            case 'p':   /* -p or --data-proc-percent */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_PERCENT == iProcSpec))
                {
                    iDataProcPercent = atoi(optarg);
                    if (iDataProcPercent > 100)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Data processing percentage "
                                       "should be less than 100!\n");
                        PrintUsage(pcProgName);
                        return SPS_RET_ERROR;
                    }

                    iProcSpec = PROC_SPEC_PERCENT;
                }
                else    /* if the specification mode is time, not percentage */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return SPS_RET_ERROR;
                }
                break;

            case 'P':   /* -P or --data-proc-time */
                /* set option */
                if ((PROC_SPEC_NOTSEL == iProcSpec)
                    || (PROC_SPEC_TIME == iProcSpec))
                {
                    iDataProcTime = atoi(optarg);
                    iProcSpec = PROC_SPEC_TIME;
                }
                else    /* if the specification mode is percentage, not time */
                {
                    (void) fprintf(stderr,
                                   "ERROR: Data processing specification mode "
                                   "should be either exclusively percentage or "
                                   "exclusively time!\n");
                    PrintUsage(pcProgName);
                    return SPS_RET_ERROR;
                }
                break;

            case 'b':   /* -b or --block-size */
                /* set option */
                iBlockSize = atoi(optarg);
                break;

            case 'o':   /* -o or --no-plots */
                /* set option */
                g_iDispPlots = SPS_FALSE;
                break;

            case 'f':   /* -f or --plot-to-file */
                /* set option */
                cIsPlotToFile = SPS_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return SPS_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return SPS_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return SPS_RET_ERROR;
    }

    if (!(cIsDMGiven))
    {
        (void) fprintf(stderr,
                       "ERROR: Required option not given! DM is required.\n");
        PrintUsage(pcProgName);
        return SPS_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = SPS_RegisterSignalHandlers();
    if (iRet != SPS_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return SPS_RET_ERROR;
    }

    /* get the input filename */
    pcFileSpec = argv[optind];

    /* NOTE: reading data in Desh's 'spec' file format + associated 'spec_cfg'
       file format */
    /* build the 'cfg' file name from the 'spec' file name, and open it */
    (void) strcpy(acFileCfg, pcFileSpec);
    (void) strcat(acFileCfg, SUFFIX_CFG);
    pFCfg = fopen(acFileCfg, "r");
    if (NULL == pFCfg)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       acFileCfg,
                       strerror(errno));
        return SPS_RET_ERROR;
    }

    /* read the first few parameters from the 'cfg' file */
    (void) fscanf(pFCfg,
                  " %lf %d %f %f %d %d %s %d %d %d %d %d %f %s %lf %lf",
                  &dTSamp,          /* in ms */
                  &iBytesPerFrame,  /* iNumChans * sizeof(float) */
                  &fFCentre,        /* in MHz */
                  &fBW,             /* in kHz */
                  &iChanBeg,
                  &iChanEnd,
                  acPulsar,
                  &iDay,
                  &iMonth,
                  &iYear,
                  &iHour,
                  &iMin,
                  &fSec,
                  acSite,
                  &dTNextBF,        /* in s */
                  &dTBFInt);        /* in s */

    /* handle negative bandwidths */
    if (fBW < 0)
    {
        fBW = -fBW;
        cIsBandFlipped = SPS_TRUE;
    }

    /* convert the bandwidth to MHz */
    fBW /= 1000.0;

    /* store a copy of the sampling interval in s */
    dTSampInSec = dTSamp / 1000.0;

    (void) printf("Field name                        : %s\n", acPulsar);
    (void) printf("Observing site                    : %s\n", acSite);
    (void) printf("Date of observation               : %d.%d.%d\n",
                  iYear,
                  iMonth,
                  iDay);
    (void) printf("Time of observation               : %d:%d:%g\n",
                  iHour,
                  iMin,
                  fSec);
    (void) printf("Bytes per frame                   : %d\n", iBytesPerFrame);
    (void) printf("Centre frequency                  : %g MHz\n", fFCentre);
    (void) printf("Bandwidth                         : %g MHz\n", fBW);
    if (cIsBandFlipped)
    {
        (void) printf("                                    Band flip.\n");
    }
    else
    {
        (void) printf("                                    No band flip.\n");
    }
    (void) printf("Sampling interval                 : %.10g ms\n", dTSamp);
    (void) printf("First channel index               : %d\n", iChanBeg);
    (void) printf("Last channel index                : %d\n", iChanEnd);

    /* calculate the number of channels */
    iNumChans = iChanEnd - iChanBeg + 1;
    (void) printf("Number of channels                : %d\n", iNumChans);

    /* calculate the channel bandwidth */
    fChanBW = fBW / iNumChans;  /* in MHz */
    (void) printf("Channel bandwidth                 : %g MHz\n", fChanBW);

    /* calculate the absolute min and max frequencies */
    fFMin = fFCentre - (fBW / 2) + (fChanBW / 2);
    (void) printf("Lowest frequency                  : %g MHz\n", fFMin);
    fFMax = fFCentre + (fBW / 2) - (fChanBW / 2);
    (void) printf("Highest frequency                 : %g MHz\n", fFMax);

    g_pcIsChanGood = (char *) malloc(sizeof(char) * iNumChans);
    if (NULL == g_pcIsChanGood)
    {
        perror("malloc - g_pcIsChanGood");
        (void) fclose(pFCfg);
        return SPS_RET_ERROR;
    }

    /* read the channel goodness flags */
    for (i = 0; i < iNumChans; ++i)
    {
        (void) fscanf(pFCfg, " %d", &iChanGoodness);
        g_pcIsChanGood[i] = (char) iChanGoodness;
        if (g_pcIsChanGood[i])
        {
            ++iNumGoodChans;
        }
    }
    (void) printf("Number of good channels           : %d\n", iNumGoodChans);

    (void) printf("First band flip time              : %.10g s\n", dTNextBF);
    (void) printf("Band flip interval                : %.10g s\n", dTBFInt);

    (void) fscanf(pFCfg, " %d", &iBFTimeSects);

    (void) printf("Number of band flip time sections : %d\n", iBFTimeSects);

    g_pfBFTimeSectMean = (float *) malloc(sizeof(float) * iBFTimeSects);
    if (NULL == g_pfBFTimeSectMean)
    {
        perror("malloc - g_pfBFTimeSectMean");
        (void) fclose(pFCfg);
        CleanUp();
        return SPS_RET_ERROR;
    }

    for (i = 0; i < iBFTimeSects; ++i)
    {
        (void) fscanf(pFCfg, " %f", &g_pfBFTimeSectMean[i]);
    }

    g_pfBFGain = (float *) malloc(sizeof(float) * iNumChans * iBFTimeSects);
    if (NULL == g_pfBFGain)
    {
        perror("malloc - g_pfBFGain");
        (void) fclose(pFCfg);
        CleanUp();
        return SPS_RET_ERROR;
    }

    for (i = 0; i < (iNumChans * iBFTimeSects); ++i)
    {
        (void) fscanf(pFCfg, " %f", &g_pfBFGain[i]);
    }
    pfTimeSectGain = g_pfBFGain;

    (void) fscanf(pFCfg, " %d", &iNumBadTimes);

    (void) printf("Number of bad time sections       : %d\n", iNumBadTimes);

    g_padBadTimes = (double (*) [][NUM_BAD_BOUNDS]) malloc(sizeof(double)
                                                           * iNumBadTimes
                                                           * NUM_BAD_BOUNDS);
    if (NULL == g_padBadTimes)
    {
        perror("malloc - g_padBadTimes");
        (void) fclose(pFCfg);
        CleanUp();
        return SPS_RET_ERROR;
    }

    for (i = 0; i < iNumBadTimes; ++i)
    {
        for (j = 0; j < NUM_BAD_BOUNDS; ++j)
        {
            (void) fscanf(pFCfg, " %lf", &((*g_padBadTimes)[i][j]));
        }
    }

    (void) fclose(pFCfg);

    g_pdDelayTab = (double *) malloc(sizeof(double) * iNumChans);
    if (NULL == g_pdDelayTab)
    {
        perror("malloc - g_pdDelayTab");
        CleanUp();
        return SPS_RET_ERROR;
    }

    /* calculate quadratic delays */
    /* NOTE: pdSpecDelay[k] may not be 0 for the highest frequency channel,
       but the offset samples may be (depending on the sampling rate) */
    if (dDM < 0)
    {
        if (cIsBandFlipped)
        {
            fF1 = fFMax;
            fF2 = fFMin;
            for (k = 0; k < iNumChans; ++k)
            {
                g_pdDelayTab[k] = -4.148808e6
                                  * ((1.0 / powf(fF1, 2)) - (1.0 / powf(fF2, 2)))
                                  * dDM;    /* in ms */
                fF2 += fChanBW;
            }
            dMaxDelay = g_pdDelayTab[0];
        }
        else
        {
            fF1 = fFMin;
            fF2 = fFMax;
            for (k = iNumChans - 1; k >= 0; --k)
            {
                g_pdDelayTab[k] = 4.148808e6
                                  * ((1.0 / powf(fF1, 2)) - (1.0 / powf(fF2, 2)))
                                  * dDM;     /* in ms */
                fF2 -= fChanBW;
            }
            dMaxDelay = g_pdDelayTab[iNumChans-1];
        }
    }
    else
    {
        if (cIsBandFlipped)
        {
            fF1 = fFMin;
            fF2 = fFMax;
            for (k = iNumChans - 1; k >= 0; --k)
            {
                g_pdDelayTab[k] = -4.148808e6
                                  * ((1.0 / powf(fF1, 2)) - (1.0 / powf(fF2, 2)))
                                  * dDM;     /* in ms */
                fF2 -= fChanBW;
            }
            dMaxDelay = g_pdDelayTab[iNumChans-1];
        }
        else
        {
            fF1 = fFMax;
            fF2 = fFMin;
            for (k = 0; k < iNumChans; ++k)
            {
                g_pdDelayTab[k] = 4.148808e6
                                  * ((1.0 / powf(fF1, 2)) - (1.0 / powf(fF2, 2)))
                                  * dDM;    /* in ms */
                fF2 += fChanBW;
            }
            dMaxDelay = g_pdDelayTab[0];
        }
    }

    /* calculate the maximum sample offset from the maximum delay */
    iMaxOffset = (int) -(dMaxDelay / dTSamp);

    /* ensure that the block size is at least equivalent to the maximum offset,
       because we don't read beyond the second buffer */
    if (iBlockSize < iMaxOffset)
    {
        (void) printf("WARNING: Block size is less than the calculated maximum "
                      "offset! Changing block size to %d.\n",
                      iMaxOffset);
        iBlockSize = iMaxOffset;
    }

    iRet = stat(pcFileSpec, &stFileStats);
    if (iRet != SPS_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to stat %s: %s!\n",
                       pcFileSpec,
                       strerror(errno));
        CleanUp();
        return SPS_RET_ERROR;
    }

    (void) printf("Duration of data in\n");
    (void) printf("    Bytes                         : %ld\n",
                  (stFileStats.st_size / iNumChans));
    iTimeSamps = stFileStats.st_size / (iNumChans * sizeof(float));
    (void) printf("    Time samples                  : %d\n", iTimeSamps);
    (void) printf("    Time                          : %g s\n",
                  (iTimeSamps * dTSampInSec));

    /* check which of the data processing specification modes - percentage or
       time - has been selected by the user, and calculate bytes to skip and
       read */
    if (PROC_SPEC_TIME == iProcSpec)
    {
        /* ensure that the input time duration is less than the length of the
           data */
        iTimeSamps = stFileStats.st_size / (iNumChans * sizeof(float));
        if (((double) iDataProcTime) > (iTimeSamps * dTSampInSec))
        {
            (void) fprintf(stderr,
                           "ERROR: Input time is longer than length of "
                           "data!\n");
            CleanUp();
            return SPS_RET_ERROR;
        }

        iBytesToSkip = (iDataSkipTime * 1000.0 / dTSamp)
                                                        /* number of samples */
                       * iNumChans
                       * sizeof(float);
        iBytesToProc = (iDataProcTime * 1000.0 / dTSamp)
                                                        /* number of samples */
                       * iNumChans
                       * sizeof(float);
    }
    else    /* if it is not selected, or percentage is selected, use percentage
               mode */
    {
        iTimeSamps = stFileStats.st_size / (iNumChans * sizeof(float));
        iBytesToSkip = floorf(iTimeSamps * (((float) iDataSkipPercent) / 100))
                                                        /* number of samples */
                       * iNumChans
                       * sizeof(float);
        iBytesToProc = ceilf(iTimeSamps * (((float) iDataProcPercent) / 100))
                                                        /* number of samples */
                       * iNumChans
                       * sizeof(float);
    }

    if (iBytesToSkip >= stFileStats.st_size)
    {
        (void) printf("WARNING: Data to be skipped is greater than or equal to "
                      "the size of the file! Terminating.\n");
        CleanUp();
        return SPS_RET_SUCCESS;
    }

    if ((iBytesToSkip + iBytesToProc) > stFileStats.st_size)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        iBytesToProc = stFileStats.st_size - iBytesToSkip;
        (void) printf("Newly calculated size of data to be processed: %d "
                      "bytes\n",
                      iBytesToProc);
    }

    if (iBlockSize == iMaxOffset)
    {
        if (iBytesToProc < (iBlockSize * iNumChans * sizeof(float)))
        {
            /* if the block size is equivalent to the maximum delay that is to
               be applied, and if the number of bytes to be processed is less
               than the block size, de-dispersion will be affected, as we don't
               have more than two block buffers. if both conditions are true,
               force the number of bytes to be processed to be equivalent to the
               block size/maximum offset */
            (void) printf("WARNING: Amount of data to be processed is less "
                          "than the calculated maximum offset! Will process "
                          "more data than what was requested.\n");
            iBytesToProc = iBlockSize * iNumChans * sizeof(float);
        }
    }
    else
    {
        /* here, iBlockSize > iMaxOffset */
        assert(iBlockSize > iMaxOffset);

        if (iBytesToProc < (iMaxOffset * iNumChans * sizeof(float)))
        {
            /* if the number of bytes to be processed is less than the maximum
               offset, de-dispersion will be affected, as we don't have more
               than two block buffers. in this situation, force the number of
               bytes to be processed to be equivalent to the maximum offset */
            (void) printf("WARNING: Amount of data to be processed is less "
                          "than the calculated maximum offset! Will process "
                          "more data than what was requested.\n");
            iBytesToProc = iMaxOffset * iNumChans *sizeof(float);
            (void) printf("WARNING: Amount of data to be processed is less "
                          "than the block size! Adjusting block size "
                          "accordingly.\n");
            iBlockSize = iBytesToProc / (iNumChans * sizeof(float));
        }
        else
        {
            if (iBytesToProc < (iBlockSize * iNumChans * sizeof(float)))
            {
                /* here, iMaxOffset <=(eqv) iBytesToProc <(eqv) iBlockSize */
                (void) printf("WARNING: Amount of data to be processed is less "
                              "than the block size! Adjusting block size "
                              "accordingly.\n");
                iBlockSize = iBytesToProc / (iNumChans * sizeof(float));
            }
        }
    }

    /* since we may have adjusted the number of bytes to be processed, correct
       the number of bytes to be skipped, too */
    if ((iBytesToSkip + iBytesToProc) > stFileStats.st_size)
    {
        (void) printf("WARNING: Total data to be read (skipped and processed) "
                      "is more than the size of the file! ");
        iBytesToSkip = stFileStats.st_size - iBytesToProc;
        (void) printf("Newly calculated size of data to be skipped: %d bytes\n",
                      iBytesToSkip);
    }

    iTimeSampsSkip = iBytesToSkip / (iNumChans * sizeof(float));
    (void) printf("Skipping %d of %d bytes (%d time samples)...\n",
                  iBytesToSkip,
                  (int) stFileStats.st_size,
                  iTimeSampsSkip);

    iTimeSamps = iBytesToProc / (iNumChans * sizeof(float));
    iNumReads = (int) ceilf(((float) iTimeSamps) / iBlockSize);
    iTotNumReads = iNumReads;

    /* optimisation - store some commonly used values in variables */
    iTotSampsPerBlock = iNumChans * iBlockSize;
    iDataSizePerBlock = sizeof(float) * iTotSampsPerBlock;

    (void) printf("Processing\n"
                  "    %d of %d bytes\n"
                  "    %d of %ld time samples\n"
                  "    %.10g of %.10g seconds\n"
                  "in %d reads with block size %d time samples...\n",
                  iBytesToProc,
                  (int) stFileStats.st_size,
                  iTimeSamps,
                  (stFileStats.st_size / (iNumChans * sizeof(float))),
                  (iTimeSamps * dTSampInSec),
                  ((stFileStats.st_size / (iNumChans * sizeof(float)))
                   * dTSampInSec),
                  iNumReads,
                  iBlockSize);

    /* calculate the threshold */
    dNumSigmas = SPS_CalcThresholdInSigmas(iTimeSamps);
    if ((double) SPS_RET_ERROR == dNumSigmas)
    {
        (void) fprintf(stderr, "ERROR: Threshold calculation failed!\n");
        CleanUp();
        return SPS_RET_ERROR;
    }
    fStatBW = iNumGoodChans * fChanBW;  /* in MHz */
    (void) printf("Usable bandwidth                  : %g MHz\n", fStatBW);
    fNoiseRMS = 1.0 / sqrt(fStatBW * dTSamp * 1e3);
    (void) printf("Expected noise RMS                : %g\n", fNoiseRMS);
    /* allocate memory for the time sample goodness flag array */
    g_pcIsTimeGood = (char *) malloc(sizeof(char) * iTimeSamps);
    if (NULL == g_pcIsTimeGood)
    {
        perror("malloc - g_pcIsTimeGood");
        CleanUp();
        return SPS_RET_ERROR;
    }
    /* set all elements to 'SPS_TRUE' */
    (void) memset(g_pcIsTimeGood, SPS_TRUE, iTimeSamps);

    /* open the 'spec' file for reading */
    pFSpec = fopen(pcFileSpec, "r");
    if (NULL == pFSpec)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileSpec,
                       strerror(errno));
        CleanUp();
        return SPS_RET_ERROR;
    }

    /* allocate memory for the primary and secondary buffers, based on the
       number of channels and time samples */
    g_pfBuf0 = (float *) malloc(iDataSizePerBlock);
    if (NULL == g_pfBuf0)
    {
        perror("malloc - g_pfBuf0");
        (void) fclose(pFSpec);
        CleanUp();
        return SPS_RET_ERROR;
    }
    g_pfBuf1 = (float *) malloc(iDataSizePerBlock);
    if (NULL == g_pfBuf1)
    {
        perror("malloc - g_pfBuf1");
        (void) fclose(pFSpec);
        CleanUp();
        return SPS_RET_ERROR;
    }

    if (1 == iNumReads)
    {
        cIsLastBlock = SPS_TRUE;
    }

    /* allocate memory for storing the cleaned spec data */
    g_pfCleanSpec = (float *) malloc(iDataSizePerBlock);
    if (NULL == g_pfCleanSpec)
    {
        perror("malloc - g_pfCleanSpec");
        (void) fclose(pFSpec);
        CleanUp();
        return SPS_RET_ERROR;
    }

    /* skip data, if any are to be skipped */
    (void) fseek(pFSpec, (long) iBytesToSkip, SEEK_SET);

    /* read the first block of data */
    (void) printf("Reading data block %d.\n", iReadBlockCount);
    (void) fread(g_pfBuf0, sizeof(float), iTotSampsPerBlock, pFSpec);
    pfPriBuf = g_pfBuf0;
    pfSpectrum = g_pfBuf0;
    iPrimaryBuf = BUF_0;
    --iNumReads;
    ++iReadBlockCount;

    /* flag bad time sections */
    for (i = 0; i < iBlockSize; ++i)
    {
        dTNow += dTSampInSec;   /* in s */

        if ((dTNow >= (*g_padBadTimes)[iBadTimeSect][BADTIME_BEG])
            && (dTNow <= (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
        {
            cIsInBadTimeRange = SPS_TRUE;
            g_pcIsTimeGood[i] = SPS_FALSE;
        }

        if ((SPS_TRUE == cIsInBadTimeRange)
            && (dTNow > (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
        {
            cIsInBadTimeRange = SPS_FALSE;
            ++iBadTimeSect;
        }

        /* get the beam flip time section corresponding to this
           sample */
        if (dTNow > dTNextBF)
        {
            dTNextBF += dTBFInt;
            if (iTimeSect >= iBFTimeSects)
            {
                (void) fprintf(stderr,
                               "ERROR: Beam flip time section anomaly "
                               "detected!\n");
                (void) fclose(pFSpec);
                CleanUp();
                return SPS_RET_ERROR;
            }
            ++iTimeSect;
        }
    }

    if (g_iDispPlots)
    {
        /* open the PGPLOT graphics device */
        if (cIsPlotToFile)
        {
            /* build the name of the PGPLOT device */
            pcFilename = SPS_GetFilenameFromPath(pcFileSpec, EXT_DYNSPEC);
            (void) strcpy(acDev, pcFilename);
            free(pcFilename);
            (void) strcat(acDev, PLOT_DDS_SUFFIX);
            (void) strcat(acDev, EXT_PS);
            (void) strcat(acDev, PG_DEV_PS);

            iRet = cpgopen(acDev);
            if (iRet <= 0)
            {
                (void) fprintf(stderr,
                               "ERROR: Opening graphics device %s failed!\n",
                               acDev);
                (void) fclose(pFSpec);
                CleanUp();
                return SPS_RET_ERROR;
            }
            cpgask(SPS_FALSE);
        }
        else
        {
            iRet = cpgopen(PG_DEV);
            if (iRet <= 0)
            {
                (void) fprintf(stderr,
                               "ERROR: Opening graphics device %s failed!\n",
                               PG_DEV);
                (void) fclose(pFSpec);
                CleanUp();
                return SPS_RET_ERROR;
            }
            cpgask(SPS_TRUE);
        }
        
        /* set up the plot's X-axis */
        g_pfXAxis = (float *) malloc(sizeof(float) * iBlockSize);
        if (NULL == g_pfXAxis)
        {
            perror("malloc - g_pfXAxis");
            cpgclos();
            (void) fclose(pFSpec);
            CleanUp();
            return SPS_RET_ERROR;
        }

        /* allocate memory for the cpgimag() plotting buffer */
        g_pfPlotBuf = (float *) malloc(sizeof(float) * iNumChans * iBlockSize);
        if (NULL == g_pfPlotBuf)
        {
            perror("malloc - g_pfPlotBuf");
            cpgclos();
            (void) fclose(pFSpec);
            CleanUp();
            return SPS_RET_ERROR;
        }
    }

    /* generate cleaned spec file name and config file name from the input
       file name */
    pcFilename = SPS_GetFilenameFromPath(pcFileSpec, EXT_DYNSPEC);

    (void) strcpy(acFileCleanSpec, pcFilename);
    (void) strcat(acFileCleanSpec, EXT_DEDISPSPEC);

    pFCleanSpec = fopen(acFileCleanSpec, "w");
    if (NULL == pFCleanSpec)
    {
        fprintf(stderr,
                "ERROR: Opening file %s failed! %s.\n",
                acFileCleanSpec,
                strerror(errno));
        (void) fclose(pFSpec);
        return SPS_RET_ERROR;
    }

    free(pcFilename);

    /* set up the plots */
    if (g_iDispPlots)
    {
        cpgsubp(1, 2);

        afTM[0] = 1;
        afTM[1] = 1;
        afTM[3] = 1;
        afTM[5] = 1;
    }

    /* dedisperse the data */
    while (iNumReads >= 0)
    {
        /* for optimisation - calculate ((iReadBlockCount - 1) * iBlockSize) */
        iReadSmpCount = (iReadBlockCount - 1) * iBlockSize;
        
        if (g_iDispPlots)
        {
            cpgpanl(1, 1);

            pfSpectrum = pfPriBuf;
            fDataMin = pfSpectrum[0];
            fDataMax = pfSpectrum[0];
            for (j = 0; j < iBlockSize; ++j)
            {
                pfSpectrum = pfPriBuf + j * iNumChans;
                for (k = 0; k < iNumChans; ++k)
                {
                    if (pfSpectrum[k] < fDataMin)
                    {
                        fDataMin = pfSpectrum[k];
                    }
                    if (pfSpectrum[k] > fDataMax)
                    {
                        fDataMax = pfSpectrum[k];
                    }
                }
            }

            (void) printf("Minimum value of data             : %g\n", fDataMin);
            (void) printf("Maximum value of data             : %g\n", fDataMax);

            if (-fThreshold > fDataMin)
            {
                fColMin = -fThreshold;
            }
            else
            {
                fColMin = fDataMin;
            }
            if (fThreshold < fDataMax)
            {
                fColMax = fThreshold;
            }
            else
            {
                fColMax = fDataMax;
            }

            iFlagBW = SPS_FALSE;

            /* for nitro
            set_colours__(&iFlagBW, &fColMin, &fColMax);
            */

            /* get the transpose of the two-dimensional array */
            k = 0;
            l = 0;
            m = 0;
            for (i = 0; i < iBlockSize; ++i)
            {
                pfSpectrum = pfPriBuf + i * iNumChans;
                for (j = 0; j < iNumChans; ++j)
                {
                    g_pfPlotBuf[l] = pfSpectrum[j];
                    l = m + k * iBlockSize;
                    ++k;
                }
                k = 0;
                l = ++m;
            }

            cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
            cpgswin(1, (iBlockSize - 1), 1, (iNumChans - 1));
            cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
            cpglab("Time (s)", "Frequency Channel", "Before De-Dispersion");
            cpgimag(g_pfPlotBuf,
                    iBlockSize,
                    iNumChans,
                    1,
                    (iBlockSize - 2),
                    1,
                    (iNumChans - 2),
                    fDataMin,
                    fDataMax,
                    afTM);
        }

        /* read the next data block, for reading samples that would be
           shifted in */
        if (!(cIsLastBlock))
        {
            (void) printf("Reading data block %d.\n", iReadBlockCount);
            if (BUF_0 == iPrimaryBuf)
            {
                iReadItems = fread(g_pfBuf1,
                                   sizeof(float),
                                   iTotSampsPerBlock,
                                   pFSpec);
                pfSecBuf = g_pfBuf1;
            }
            else
            {
                iReadItems = fread(g_pfBuf0,
                                   sizeof(float),
                                   iTotSampsPerBlock,
                                   pFSpec);
                pfSecBuf = g_pfBuf0;
            }
            if (ferror(pFSpec))
            {
                (void) fprintf(stderr, "ERROR: File read failed!\n");
                if (g_iDispPlots)
                {
                    cpgclos();
                }
                (void) fclose(pFCleanSpec);
                (void) fclose(pFSpec);
                CleanUp();
                return SPS_RET_ERROR;
            }
            if (iReadItems < iTotSampsPerBlock)
            {
                iDiff = iTotSampsPerBlock - iReadItems;

                /* reset remaining elements to '\0' */
                if (BUF_0 == iPrimaryBuf)
                {
                    (void) memset((g_pfBuf1 + iReadItems),
                                  '\0',
                                  (sizeof(float) * iDiff));
                }
                else
                {
                    (void) memset((g_pfBuf0 + iReadItems),
                                  '\0',
                                  (sizeof(float) * iDiff));
                }
            }

            /* calculate the number of time samples in the block - this may not
               be iBlockSize for the last block, and should be iBlockSize for
               all other blocks */
            iNumSamps = iReadItems / iNumChans;

            /* get the actual count of read samples, inclusive of those in the
               first buffer */
            iSecBufReadSampCount = iReadBlockCount * iBlockSize;

            /* flag bad time sections */
            for (i = 0; i < iNumSamps; ++i)
            {
                dTNow += dTSampInSec;   /* in s */

                if ((dTNow >= (*g_padBadTimes)[iBadTimeSect][BADTIME_BEG])
                    && (dTNow
                        <= (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
                {
                    cIsInBadTimeRange = SPS_TRUE;
                    g_pcIsTimeGood[iSecBufReadSampCount+i] = SPS_FALSE;
                }

                if ((SPS_TRUE == cIsInBadTimeRange)
                    && (dTNow
                        > (*g_padBadTimes)[iBadTimeSect][BADTIME_END]))
                {
                    cIsInBadTimeRange = SPS_FALSE;
                    ++iBadTimeSect;
                }

                /* get the beam flip time section corresponding to this
                   sample */
                if (dTNow > dTNextBF)
                {
                    dTNextBF += dTBFInt;
                    if (iTimeSect >= iBFTimeSects)
                    {
                        (void) fprintf(stderr,
                                       "ERROR: Beam flip time section anomaly "
                                       "detected!\n");
                        if (g_iDispPlots)
                        {
                            cpgclos();
                        }
                        (void) fclose(pFCleanSpec);
                        (void) fclose(pFSpec);
                        CleanUp();
                        return SPS_RET_ERROR;
                    }
                    ++iTimeSect;
                }
            }
        }

        (void) printf("Processing data block %d.\n", (iReadBlockCount - 1));

        /* clear the g_pfCleanSpec array */
        (void) memset(g_pfCleanSpec,
                      '\0',
                      iDataSizePerBlock);

        for (k = 0; k < iBlockSize; ++k)
        {
            pfSpectrum = pfPriBuf + k * iNumChans;
            pfCleanSpectrum = g_pfCleanSpec + k * iNumChans;
            for (l = 0; l < iNumChans; ++l)
            {
                if (g_pcIsChanGood[l])
                {
                    /* get the delay for the corresponding DM and frequency
                       channel from the delay table */
                    dDelay = g_pdDelayTab[l];
                    /* calculate the sample number offset from the delay */
                    iOffset = (int) -(dDelay / dTSamp);
                    /* apply the delay - shift all time samples up */
                    if ((k + iOffset) >= iBlockSize)
                    {
                        if (!(cIsLastBlock))
                        {
                            m = k + iOffset - iBlockSize;
                            pfOffsetSpec = pfSecBuf + m * iNumChans;
                            pfSpectrum[l] = pfOffsetSpec[l];
                            if (g_pcIsTimeGood[iReadSmpCount+k+iOffset])
                            {
                                pfCleanSpectrum[l] = pfSpectrum[l];
                            }
                        }
                    }
                    else
                    {
                        pfOffsetSpec = pfPriBuf
                                       + (k + iOffset) * iNumChans;
                        pfSpectrum[l] = pfOffsetSpec[l];
                        if (g_pcIsTimeGood[iReadSmpCount+k+iOffset])
                        {
                            pfCleanSpectrum[l] = pfSpectrum[l];
                        }
                    }
                }
            }
        }

        if (g_iDispPlots)
        {
            cpgpanl(1, 2);

            pfCleanSpectrum = g_pfCleanSpec;
            fDataMin = pfCleanSpectrum[0];
            fDataMax = pfCleanSpectrum[0];
            for (j = 0; j < iBlockSize; ++j)
            {
                pfCleanSpectrum = g_pfCleanSpec + j * iNumChans;
                for (k = 0; k < iNumChans; ++k)
                {
                    if (pfCleanSpectrum[k] < fDataMin)
                    {
                        fDataMin = pfCleanSpectrum[k];
                    }
                    if (pfCleanSpectrum[k] > fDataMax)
                    {
                        fDataMax = pfCleanSpectrum[k];
                    }
                }
            }

            (void) printf("Minimum value of data             : %g\n", fDataMin);
            (void) printf("Maximum value of data             : %g\n", fDataMax);

            if (-fThreshold > fDataMin)
            {
                fColMin = -fThreshold;
            }
            else
            {
                fColMin = fDataMin;
            }
            if (fThreshold < fDataMax)
            {
                fColMax = fThreshold;
            }
            else
            {
                fColMax = fDataMax;
            }

            iFlagBW = SPS_FALSE;
            set_colours__(&iFlagBW, &fColMin, &fColMax);
            /* get the transpose of the two-dimensional array */
            k = 0;
            l = 0;
            m = 0;
            for (i = 0; i < iBlockSize; ++i)
            {
                pfCleanSpectrum = g_pfCleanSpec + i * iNumChans;
                for (j = 0; j < iNumChans; ++j)
                {
                    g_pfPlotBuf[l] = pfCleanSpectrum[j];
                    l = m + k * iBlockSize;
                    ++k;
                }
                k = 0;
                l = ++m;
            }

            cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
            cpgswin(1, (iBlockSize - 1), 1, (iNumChans - 1));
            cpgbox("BCNST", 0.0, 0, "BCNST", 0.0, 0);
            cpglab("Time (s)", "Frequency Channel", "After De-Dispersion");
            cpgimag(g_pfPlotBuf,
                    iBlockSize,
                    iNumChans,
                    1,
                    (iBlockSize - 2),
                    1,
                    (iNumChans - 2),
                    fDataMin,
                    fDataMax,
                    afTM);

            if (!(cIsLastBlock))
            {
                cpgpage();
            }
        }

        (void) fwrite(g_pfCleanSpec,
                      sizeof(float),
                      iTotSampsPerBlock,
                      pFCleanSpec);

        if (BUF_0 == iPrimaryBuf)
        {
            iPrimaryBuf = BUF_1;
            pfPriBuf = g_pfBuf1;
        }
        else
        {
            iPrimaryBuf = BUF_0;
            pfPriBuf = g_pfBuf0;
        }

        --iNumReads;
        ++iReadBlockCount;
        if (0 == iNumReads)
        {
            cIsLastBlock = SPS_TRUE;
        }
    }

    (void) printf("DONE!\n");

    if (g_iDispPlots)
    {
        cpgclos();
    }

    (void) fclose(pFCleanSpec);
    (void) fclose(pFSpec);
    CleanUp();

    return SPS_RET_SUCCESS;
}

/*
 * Cleans up all allocated memory
 */
void CleanUp()
{
    if (g_pfCleanSpec != NULL)
    {
        free(g_pfCleanSpec);
        g_pfCleanSpec = NULL;
    }
    if (g_pfBuf0 != NULL)
    {
        free(g_pfBuf0);
        g_pfBuf0 = NULL;
    }
    if (g_pfBuf1 != NULL)
    {
        free(g_pfBuf1);
        g_pfBuf1 = NULL;
    }
    if (g_padBadTimes != NULL)
    {
        free(g_padBadTimes);
        g_padBadTimes = NULL;
    }
    if (g_pfBFGain != NULL)
    {
        free(g_pfBFGain);
        g_pfBFGain = NULL;
    }
    if (g_pfBFTimeSectMean != NULL)
    {
        free(g_pfBFTimeSectMean);
        g_pfBFTimeSectMean = NULL;
    }
    if (g_pcIsChanGood != NULL)
    {
        free(g_pcIsChanGood);
        g_pcIsChanGood = NULL;
    }
    if (g_pcIsTimeGood != NULL)
    {
        free(g_pcIsTimeGood);
        g_pcIsTimeGood = NULL;
    }
    if (g_iDispPlots)
    {
        if (g_pfPlotBuf != NULL)
        {
            free(g_pfPlotBuf);
            g_pfPlotBuf = NULL;
        }
    }

    return;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <spec-file>\n", pcProgName);
    (void) printf("    -h  --help                           ");
    (void) printf("Display this usage information\n");
    (void) printf("    -d  --dm <dm>                        ");
    (void) printf("The quasi-DM at which the RFI is\n");
    (void) printf("                                         ");
    (void) printf("'dispersed'\n");
    (void) printf("    -s  --data-skip-percent <percentage> ");
    (void) printf("The percentage of data to be skipped\n");
    (void) printf("    -S  --data-skip-time <time>          ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                         ");
    (void) printf("skipped\n");
    (void) printf("    -p  --data-proc-percent <percentage> ");
    (void) printf("The percentage of data to be processed\n");
    (void) printf("                                         ");
    (void) printf("(default is 100)\n");
    (void) printf("    -P  --data-proc-time <time>          ");
    (void) printf("The length of data in seconds, to be\n");
    (void) printf("                                         ");
    (void) printf("processed\n");
    (void) printf("                                         ");
    (void) printf("(default is all)\n");
    (void) printf("    -b  --block-size <size>              ");
    (void) printf("Size of each file read/write in bytes\n");
    (void) printf("    -o  --no-plots                       ");
    (void) printf("Run without displaying plots\n");
    (void) printf("    -f  --plot-to-file                   ");
    (void) printf("Plot to a PostScript file, instead of\n");
    (void) printf("                                         ");
    (void) printf("the screen\n");
    (void) printf("    -v  --version                        ");
    (void) printf("Display the version\n");

    return;
}

