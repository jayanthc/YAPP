/**
 * @file yapp_pulsarsnd.c
 * Makes music out of a pulsar (converts dedispersed data to WAVE data)
 *
 * @verbatim
 * Usage: pulsarsnd [options] <dedispersed-data-file>
 *     -s  --samples <samples-per-sec>      Samples per second
 *     -a  --ampfactor <amp-scale-factor>   Amplitude scale factor
 *     -b  --header <header-bytes-to-skip>  Header bytes to skip
 *     -w  --swap                           Swap flag
 *     -h  --help                           Display this usage information
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @author Desh
 * @date 2007.*.*
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include <sys/stat.h>
#include <sndfile.h>

#include "yapp.h"

#define CHANNEL_COUNT       1
#define FILE_EXT            ".wav"

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

int main(int argc, char *argv[])
{
    SF_INFO stSFInfo = {0};
    SNDFILE *pFSndFile = NULL;
    char acFileSnd[LEN_GENSTRING] = {0};
    char *pcFileDedispData = NULL;
    FILE *pFDedispData = NULL;
    float *pfData = NULL;
    char *pcHeader = NULL;
    float fMax = -(FLT_MAX);
    float fMin = FLT_MAX;
    float fMean = 0.0;
    float fRMS = 0.0;
    float temp;
    float f_temp = 0;
    int iFileSize = 0;
    int iTimeSamps = 0;
    int iSamplingRate = 0;
    int iSkip = 0;
    char cFlagSwap = YAPP_FALSE;
    float fAmpFactor = 0.0;
    struct stat stFileStats;
    char *s,*s_temp,x_char;
    char *ss;
    int iRet = YAPP_RET_SUCCESS;
    int i = 0;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "s:a:b:whv";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "samples",                1, NULL, 's' },
        { "ampfactor",              1, NULL, 'a' },
        { "header",                 1, NULL, 'b' },
        { "swap",                   0, NULL, 'w' },
        { "help",                   0, NULL, 'h' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 's':   /* -s or --samples */
                /* set option */
                iSamplingRate = atoi(optarg);
                if (0 == iSamplingRate)
                {
                    (void) fprintf(stderr, "ERROR: Invalid sampling rate!\n");
                    PrintUsage(pcProgName);
                    return YAPP_RET_ERROR;
                }
                break;

            case 'a':   /* -a or --ampfactor */
                /* set option */
                fAmpFactor = atof(optarg);
                break;

            case 'b':   /* -b or --header */
                /* set option */
                iSkip = atoi(optarg);
                break;

            case 'w':   /* -w or --swap */
                /* set option */
                cFlagSwap = YAPP_TRUE;
                break;

            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileDedispData = argv[optind];

    /* generate the output file name */
    (void) strncat(acFileSnd, pcFileDedispData, LEN_GENSTRING);
    (void) strncat(acFileSnd, FILE_EXT, LEN_GENSTRING);

    /* open the file containing the dedispersed data */
    pFDedispData = fopen(pcFileDedispData, "r");
    if (NULL == pFDedispData)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileDedispData,
                       strerror(errno));
        return YAPP_RET_ERROR;
    }

    /* get the size of the file */
    iRet = stat(pcFileDedispData,&stFileStats);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to stat %s: %s!\n",
                       pcFileDedispData,
                       strerror(errno));
        CleanUp();
        return YAPP_RET_ERROR;
    }
    iFileSize = stFileStats.st_size;
    (void) printf("Dedispersed data file size        : %d\n", iFileSize);

    /* calculate the number of time samples */
    iTimeSamps = (iFileSize - iSkip) / sizeof(float);
    (void) printf("Number of time samples            : %d\n", iTimeSamps);

    /* allocate memory and read in the data */
    pcHeader = (char *) malloc(sizeof(char) * iSkip);
    if (NULL == pcHeader)
    {
        perror("malloc - pcHeader");
        CleanUp();
        return YAPP_RET_ERROR;
    }

//  s = (char *) malloc(iFileSize * sizeof(float));
    pfData = (float *) malloc(sizeof(float) * iTimeSamps);
    if (NULL == pfData)
    {
        perror("malloc - pfData");
        CleanUp();
        return YAPP_RET_ERROR;
    }

#if 0
    for (i = 0; i < iTimeSamps; ++i)
    {
      pfData[i] = sin((float)i/100.);  // simulation
        //pfData[i] = fgetc(pFDedispData);    // or data
    }
#endif

#if 0   //jayanth
    /* read the header */
    (void) fgets(pcHeader, (sizeof(char) * iSkip), pFDedispData);
#endif

#if 0
    if (NULL == iRet)
    {
        perror("fgets");
        CleanUp();
        return YAPP_RET_ERROR;
    }
#endif

    /* read the dedispersed data */
        //iRet = (int)fgets((char *) pfData, (iFileSize*sizeof(float)), pFDedispData);
//        if ((iRet = read(pFDedispData,s,(iFileSize*sizeof(float)))) != (iFileSize*sizeof(float)))
    iRet = fread(pfData, sizeof(float), iTimeSamps, pFDedispData);
    if (YAPP_RET_ERROR == iRet)  //TODO: ferror()
    {
        printf("ERROR: Cannot get data from the file!\n");
        return YAPP_RET_ERROR;
    }

    ss = (char *)&pfData[1];
                printf(" ss1,2,3,4 %d %d %d %d\n",ss[0],ss[1],ss[2],ss[3]);
        printf("%f\n", pfData[1]);
    if (cFlagSwap)
    {       // s = (char *)pfData;
        //s_temp = (char *)f_temp;
        for (i = 0; i < iTimeSamps; ++i)
        {
    //  printf("%f    ", pfData[i]);
            f_temp = pfData[i];
            s_temp = (char *) &f_temp;
            x_char = s_temp[0];
            s_temp[0] = s_temp[3];
            s_temp[3] = x_char;
            x_char = s_temp[1];
            s_temp[1] = s_temp[2];
            s_temp[2] = x_char;
            pfData[i] = f_temp;
    //  printf("    %f\n", pfData[i]);
        }
        printf(" ss1,2,3,4 %d %d %d %d\n",ss[0],ss[1],ss[2],ss[3]);
        printf("%x\n", (int) &pfData[1]);
    }
//#endif

    /* calculate the mean of the data, subtract the mean from the
       samples, and multiply the signal by fAmpFactor */
    fMax = pfData[0];
    fMin = pfData[0];
    fMean = 0.0;
    for (i = 1; i < iTimeSamps; ++i)
    {
        if (pfData[i] > fMax)
        {
            fMax = pfData[i];
        }
        if (pfData[i] < fMin)
        {
            fMin = pfData[i];
        }
        fMean += pfData[i];
        fRMS += (pfData[i] * pfData[i]);
    }
    fMean = fMean / iTimeSamps;
    fRMS = sqrtf(fRMS / iTimeSamps);
    printf("min,max: %f %f; Mean %f, RMS %g\n",fMin,fMax,fMean, fRMS);

    if ((fMax - fMin) > 1.e10)
    {
        fAmpFactor = 1.e10;
    }
    else
    {
        if ((fMax - fMin) < 1.e-10)
        {
            fAmpFactor = 1.0e-10;
        }
        else
        {
            fAmpFactor = 10.0 / (fMax - fMin);
        }
    }

    for (i = 0; i < iTimeSamps; ++i)
    {
        if (pfData[i] < (1.5 * fRMS))
        {
            pfData[i] = 0.0;
        }
        //pfData[i] -= fMean;
        pfData[i] = powf(10, pfData[i]);
        pfData[i] *= fAmpFactor;
    }

    /* set the parameters for the WAVE file */
    stSFInfo.samplerate = iSamplingRate;
    stSFInfo.channels = CHANNEL_COUNT;
    stSFInfo.format = (SF_FORMAT_WAV | SF_FORMAT_FLOAT);

    /* open the WAVE file and write the processed data */
    pFSndFile = sf_open(acFileSnd, SFM_WRITE, &stSFInfo);
    if (NULL == pFSndFile)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to open WAVE file: %s!\n",
                       sf_strerror(pFSndFile));
        free(pfData);
        return YAPP_RET_ERROR;
    }
//  if (sf_write_int(pFSndFile, pfData, iFileSize) != iFileSize)
    if (sf_write_float(pFSndFile, pfData, iTimeSamps) != iTimeSamps)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to write to WAVE file: %s!\n",
                       sf_strerror(pFSndFile));
        free(pfData);
        sf_close(pFSndFile);
        return YAPP_RET_ERROR;
    }

    /* clean up */
    sf_close(pFSndFile);
    free(pfData);
    fclose(pFDedispData);

    return YAPP_RET_SUCCESS;
}

/*
 * Cleans up all allocated memory
 */
void CleanUp()
{
#if 0
    if (g_padBadTimes != NULL)
    {
        free(g_padBadTimes);
        g_padBadTimes = NULL;
    }
#endif
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <dedispersed-data-file>\n", pcProgName);
    (void) printf("    -s  --samples <samples-per-sec>      ");
    (void) printf("Samples per second\n");
    (void) printf("    -a  --ampfactor <amp-scale-factor>   ");
    (void) printf("Amplitude scale factor\n");
    (void) printf("    -b  --header <header-bytes-to-skip>  ");
    (void) printf("Header bytes to skip\n");
    (void) printf("    -w  --swap                           ");
    (void) printf("Swap flag\n");
    (void) printf("    -h  --help                           ");
    (void) printf("Display this usage information\n");
    (void) printf("    -v  --version                        ");
    (void) printf("Display the version\n");

    return;
}

