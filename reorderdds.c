/**
 * @file reorderdds.c
 * Program to re-order the dedispersed spectrum.
 *
 * @verbatim
 * Usage: reorderdds [options] <spec-file>
 *     -h  --help                           Display this usage information
 *     -f  --plot-to-file                   Plot to a PostScript file, instead
 *                                          of the screen
 *     -v  --version                        Display the version @endverbatim
 *
 * @author Jayanth Chennamangalam
 * @date 2009.07.14
 */

#include "yapp.h"

/**
 * The build version string, maintained in the file version.c, which is
 * generated by makever.c.
 */
extern const char *g_pcVersion;

/* the following are global only to enable cleaning up in case of abnormal
   termination, such as those triggered by SIGINT or SIGTERM */
float *g_pfBuf = NULL;
double *g_pdDM = NULL;
float *g_pfDedispSpec = NULL;
float *g_pfXAxis = NULL;

int main(int argc, char *argv[])
{
    FILE *pFDDS = NULL;
    FILE *pFCfg = NULL;
    char *pcFileDDS = NULL;
    char acFilename[LEN_GENSTRING] = {0};
    double dDMMin = 0.0;
    double dDMMax = 0.0;
    char cIsPlotToFile = YAPP_FALSE;
    double dDMStep = 0.0;
    int iNumDMs = 0;
    float *pfDMChan = NULL;
    double dTSampInSec = 0.0;   /* holds sampling time in s */
    float *pfDSWritePointer = NULL;
    int iTimeSamps = 0;
    int iTimeSampsInFile = 0;
    int iBlockSize = 0;
    int iNumBlocks = 0;
    int iReadBlockCount = 0;
    int iBytesToCopy = 0;
    struct stat stFileStats = {0};
    int iRet = YAPP_RET_SUCCESS;
    int iFlagBW = 0;
    float afTM[6] = {0.0};
    float fDataMin = 0.0;
    float fDataMax = 0.0;
    char acDev[LEN_GENSTRING] = {0};
    char *pcFilename = NULL;
    float fXStep = 0.0;
    float fYStep = 0.0;
    int i = 0;
    int j = 0;
    double dTemp = 0.0;
    const char *pcProgName = NULL;
    int iNextOpt = 0;
    /* valid short options */
    const char* const pcOptsShort = "hfv";
    /* valid long options */
    const struct option stOptsLong[] = {
        { "help",                   0, NULL, 'h' },
        { "plot-to-file",           0, NULL, 'f' },
        { "version",                0, NULL, 'v' },
        { NULL,                     0, NULL, 0   }
    };

    /* get the filename of the program from the argument list */
    pcProgName = argv[0];

    /* parse the input */
    do
    {
        iNextOpt = getopt_long(argc, argv, pcOptsShort, stOptsLong, NULL);
        switch (iNextOpt)
        {
            case 'h':   /* -h or --help */
                /* print usage info and terminate */
                PrintUsage(pcProgName);
                return YAPP_RET_SUCCESS;

            case 'f':   /* -f or --plot-to-file */
                /* set option */
                cIsPlotToFile = YAPP_TRUE;
                break;

            case 'v':   /* -v or --version */
                /* display the version */
                (void) printf("%s\n", g_pcVersion);
                return YAPP_RET_SUCCESS;

            case '?':   /* user specified an invalid option */
                /* print usage info and terminate with error */
                (void) fprintf(stderr, "ERROR: Invalid option!\n");
                PrintUsage(pcProgName);
                return YAPP_RET_ERROR;

            case -1:    /* done with options */
                break;

            default:    /* unexpected */
                assert(0);
        }
    } while (iNextOpt != -1);

    /* no arguments */
    if (argc <= optind)
    {
        (void) fprintf(stderr, "ERROR: Input file not specified!\n");
        PrintUsage(pcProgName);
        return YAPP_RET_ERROR;
    }

    /* register the signal-handling function */
    iRet = YAPP_RegisterSignalHandlers();
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Handler registration failed!\n");
        return YAPP_RET_ERROR;
    }

    /* get the input filename */
    pcFileDDS = argv[optind];

    /* NOTE: reading the cfg file in the format required by
       'sl_bl_stat_n_search' */
    /* build the 'cfg' file name from the 'dds' file name, and open it */
    (void) strcpy(acFilename, pcFileDDS);
    acFilename[strlen(acFilename)-strlen(EXT_DEDISPSPEC)] = '\0';
    (void) strcat(acFilename, EXT_DEDISPSPECCFG);
    pFCfg = fopen(acFilename, "r");
    if (NULL == pFCfg)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       acFilename,
                       strerror(errno));
        return YAPP_RET_ERROR;
    }

    /* read the first few parameters from the 'cfg' file */
    (void) fscanf(pFCfg,
                  " %lf %lf %lf %lf %lf %lf %d %d %lf %lf %d %d",
                  &dTemp,   /* minimum frequency */
                  &dTemp,   /* maximum frequency */
                  &dTemp,   /* start time */
                  &dTemp,   /* stop time */
                  &dDMMin,
                  &dDMMax,
                  &iNumDMs,
                  &iTimeSamps,
                  &dTSampInSec,
                  &dDMStep,
                  &iNumBlocks,
                  &iBlockSize);

    (void) printf("Minimum DM                        : %.10g cm^-3 pc\n",
                  dDMMin);
    (void) printf("Maximum DM                        : %.10g cm^-3 pc\n",
                  dDMMax);
    (void) printf("Number of DM channels             : %d\n", iNumDMs);
    (void) printf("Sampling period                   : %.10g s\n", dTSampInSec);
    (void) printf("DM step size                      : %.10g cm^-3 pc\n",
                  dDMStep);
    (void) printf("Number of blocks                  : %d\n", iNumBlocks);
    (void) printf("Block size                        : %d\n", iBlockSize);

    iRet = stat(pcFileDDS, &stFileStats);
    if (iRet != YAPP_RET_SUCCESS)
    {
        (void) fprintf(stderr,
                       "ERROR: Failed to stat %s: %s!\n",
                       pcFileDDS,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* sanity check */
    iTimeSampsInFile = stFileStats.st_size / (iNumDMs * sizeof(float));
    if (iTimeSamps > iTimeSampsInFile)
    {
        (void) fprintf(stderr,
                       "ERROR: Incongruency in number of time samples!\n");
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    (void) printf("Time samples containing data      : %d\n", iTimeSamps);

    /* open the dedispersed spec file for reading */
    pFDDS = fopen(pcFileDDS, "r");
    if (NULL == pFDDS)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       pcFileDDS,
                       strerror(errno));
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    /* allocate memory for the block buffer, based on the number of DM channels
       and time samples in one block  */
    g_pfBuf = (float *) malloc(sizeof(float) * iNumDMs * iBlockSize);
    if (NULL == g_pfBuf)
    {
        perror("malloc - g_pfBuf");
        (void) fclose(pFDDS);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    g_pfDedispSpec = (float *) malloc(sizeof(float) * iNumDMs * iTimeSamps);
    if (NULL == g_pfDedispSpec)
    {
        perror("malloc - g_pfDedispSpec");
        (void) fclose(pFDDS);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    pfDSWritePointer = g_pfDedispSpec;

    for (i = 0; i < iNumDMs; ++i)
    {
        while (iReadBlockCount < iNumBlocks)
        {
            /* read the first block of data */
            iRet = fread(g_pfBuf, sizeof(float), iNumDMs * iBlockSize, pFDDS);
            if (iRet < (iNumDMs * iBlockSize))
            {
                (void) fprintf(stderr,
                               "ERROR: Insufficient number of data items read!\n");
                (void) fclose(pFDDS);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            if (ferror(pFDDS))
            {
                (void) fprintf(stderr,
                               "ERROR: Data read failed!\n");
                (void) fclose(pFDDS);
                YAPP_CleanUp();
                return YAPP_RET_ERROR;
            }
            ++iReadBlockCount;

            /* get the offset to this DM channel */
            pfDMChan = g_pfBuf + i * iBlockSize;

            /* compute the size of the data to be copied */
            if (iNumBlocks == iReadBlockCount)        /* last block */
            {
                iBytesToCopy = sizeof(float)
                               * (iTimeSamps
                                  - ((iReadBlockCount - 1) * iBlockSize));
            }
            else
            {
                iBytesToCopy = sizeof(float) * iBlockSize;  /* not last block */
            }

            /* copy this DM channel to the g_pfDedispSpec array */
            (void) memcpy(pfDSWritePointer, pfDMChan, iBytesToCopy);
            pfDSWritePointer += (iBytesToCopy / sizeof(float));
        }

        rewind(pFDDS);
        iReadBlockCount = 0;
    }

    /* open the PGPLOT graphics device */
    if (cIsPlotToFile)
    {
        /* build the name of the PGPLOT device */
        pcFilename = YAPP_GetFilenameFromPath(pcFileDDS, EXT_DEDISPSPEC);
        (void) strcpy(acDev, pcFilename);
        free(pcFilename);
        (void) strcat(acDev, PLOT_DDS_SUFFIX);
        (void) strcat(acDev, EXT_PS);
        (void) strcat(acDev, PG_DEV_PS);

        iRet = cpgopen(acDev);
        if (iRet <= 0)
        {
            (void) fprintf(stderr,
                           "ERROR: Opening graphics device %s failed!\n",
                           acDev);
            (void) fclose(pFDDS);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        cpgask(YAPP_FALSE);
    }
    else
    {
        iRet = cpgopen(PG_DEV);
        if (iRet <= 0)
        {
            (void) fprintf(stderr,
                           "ERROR: Opening graphics device %s failed!\n",
                           PG_DEV);
            (void) fclose(pFDDS);
            YAPP_CleanUp();
            return YAPP_RET_ERROR;
        }
        cpgask(YAPP_TRUE);
    }

    /* set the background colour to white and the foreground colour to
       black */
    cpgscr(0, 1.0, 1.0, 1.0);
    cpgscr(1, 0.0, 0.0, 0.0);

    /* set up the plot's X-axis */
    g_pfXAxis = (float *) malloc(sizeof(float) * iTimeSamps);
    if (NULL == g_pfXAxis)
    {
        perror("malloc - g_pfXAxis");
        cpgclos();
        (void) fclose(pFDDS);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    for (i = 0; i < iTimeSamps; ++i)
    {
        g_pfXAxis[i] = (float) (i * dTSampInSec);
    }

    /* set up the image plot's Y-axis (DM) */
    g_pdDM = (double *) malloc(sizeof(double) * iNumDMs);
    if (NULL == g_pdDM)
    {
        perror("malloc - g_pdDM");
        cpgclos();
        (void) fclose(pFDDS);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    for (i = 0; i < iNumDMs; ++i)
    {
        g_pdDM[i] = dDMMin + i * dDMStep;
    }

    /* calculate the tick step sizes */
    fXStep = (int) ((((iTimeSamps - 1) * dTSampInSec) - 0)
                    / PG_TICK_STEPS_X);
    fYStep = (int) ((dDMMax - dDMMin) / PG_TICK_STEPS_Y);

    afTM[0] = 1;
    afTM[1] = 1;
    afTM[3] = 1;
    afTM[5] = 1;

    pfDMChan = g_pfDedispSpec;
    fDataMin = pfDMChan[0];
    fDataMax = pfDMChan[0];
    for (i = 0; i < iNumDMs; ++i)
    {
        pfDMChan = g_pfDedispSpec + i * iTimeSamps;
        for (j = 0; j < iTimeSamps; ++j)
        {
            if (pfDMChan[j] < fDataMin)
            {
                fDataMin = pfDMChan[j];
            }
            if (pfDMChan[j] > fDataMax)
            {
                fDataMax = pfDMChan[j];
            }
        }
    }

    (void) printf("Minimum value of data             : %g\n", fDataMin);
    (void) printf("Maximum value of data             : %g\n", fDataMax);

    iFlagBW = YAPP_FALSE;

    #ifdef _FC_F77_    /* if using Fortran 77 compiler */
    set_colours__(&iFlagBW, &fDataMin, &fDataMax);
    #else           /* for Fortran 95 */
    set_colours_(&iFlagBW, &fDataMin, &fDataMax);
    #endif
    //SetColourMap(iFlagBW, fColMin, fColMax);

    cpgsvp(PG_VP_ML, PG_VP_MR, PG_VP_MB, PG_VP_MT);
    cpgswin(1, (iTimeSamps - 2), 1, (iNumDMs - 2));
    cpgbox("C", 0.0, 0, "C", 0.0, 0);
    cpgaxis("N",
            1, 1,
            (iTimeSamps - 2), 1,
            g_pfXAxis[1], g_pfXAxis[iTimeSamps-2],
            fXStep,
            0,
            0.0,
            0.4,
            1.0,
            0.8,
            0);
    cpgaxis("N",
            1, 1,
            1, (iNumDMs - 2),
            g_pdDM[1], g_pdDM[iNumDMs-2],
            fYStep,
            0,
            0.4,
            0.0,
            1.0,
            -0.8,
            0);
    cpglab("Time (s)", "DM (cm\\u-3\\d pc)", "DM vs. Time");
    cpgimag(g_pfDedispSpec,
            iTimeSamps,
            iNumDMs,
            1,
            (iTimeSamps - 2),
            1,
            (iNumDMs - 2),
            fDataMin,
            fDataMax,
            afTM);
    cpgwedg("RI", 1.0, 5.0, fDataMin, fDataMax, "");

    cpgclos();
    (void) fclose(pFDDS);

    /* write the re-ordered data to disk */
    pcFilename = YAPP_GetFilenameFromPath(pcFileDDS, EXT_DEDISPSPEC);
    (void) strcpy(acFilename, pcFilename);
    free(pcFilename);
    (void) strcat(acFilename, ".rdds");
    pFDDS = fopen(acFilename, "w");
    if (NULL == pFDDS)
    {
        (void) fprintf(stderr,
                       "ERROR: Opening file %s failed! %s.\n",
                       acFilename,
                       strerror(errno));
        return YAPP_RET_ERROR;
    }

    iRet = fwrite(g_pfDedispSpec, sizeof(float), (iNumDMs * iTimeSamps), pFDDS);
    if (iRet < (iNumDMs * iTimeSamps))
    {
        (void) fprintf(stderr,
                       "ERROR: Insufficient number of data items read!\n");
        (void) fclose(pFDDS);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }
    if (ferror(pFDDS))
    {
        (void) fprintf(stderr,
                       "ERROR: Data read failed!\n");
        (void) fclose(pFDDS);
        YAPP_CleanUp();
        return YAPP_RET_ERROR;
    }

    (void) printf("DONE!\n");

    YAPP_CleanUp();

    return YAPP_RET_SUCCESS;
}

/*
 * Cleans up all allocated memory
 */
void YAPP_CleanUp()
{
    if (g_pfBuf != NULL)
    {
        free(g_pfBuf);
        g_pfBuf = NULL;
    }
    if (g_pfDedispSpec != NULL)
    {
        free(g_pfDedispSpec);
        g_pfDedispSpec = NULL;
    }

    return;
}

/*
 * Prints usage information
 */
void PrintUsage(const char *pcProgName)
{
    (void) printf("Usage: %s [options] <spec-file>\n", pcProgName);
    (void) printf("    -h  --help                           ");
    (void) printf("Display this usage information\n");
    (void) printf("    -f  --plot-to-file                   ");
    (void) printf("Plot to a PostScript file, instead of\n");
    (void) printf("                                         ");
    (void) printf("the screen\n");
    (void) printf("    -v  --version                        ");
    (void) printf("Display the version\n");

    return;
}

